// source: proto/types/action.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.iotextypes.AccessTuple', null, global);
goog.exportSymbol('proto.iotextypes.Action', null, global);
goog.exportSymbol('proto.iotextypes.ActionCore', null, global);
goog.exportSymbol('proto.iotextypes.ActionCore.ActionCase', null, global);
goog.exportSymbol('proto.iotextypes.ActionEvmTransfer', null, global);
goog.exportSymbol('proto.iotextypes.BlockEvmTransfer', null, global);
goog.exportSymbol('proto.iotextypes.Candidate', null, global);
goog.exportSymbol('proto.iotextypes.CandidateBasicInfo', null, global);
goog.exportSymbol('proto.iotextypes.CandidateList', null, global);
goog.exportSymbol('proto.iotextypes.CandidateRegister', null, global);
goog.exportSymbol('proto.iotextypes.ClaimFromRewardingFund', null, global);
goog.exportSymbol('proto.iotextypes.CreateDeposit', null, global);
goog.exportSymbol('proto.iotextypes.CreatePlumChain', null, global);
goog.exportSymbol('proto.iotextypes.DepositToRewardingFund', null, global);
goog.exportSymbol('proto.iotextypes.Encoding', null, global);
goog.exportSymbol('proto.iotextypes.EvmTransfer', null, global);
goog.exportSymbol('proto.iotextypes.EvmTransferList', null, global);
goog.exportSymbol('proto.iotextypes.Execution', null, global);
goog.exportSymbol('proto.iotextypes.GrantReward', null, global);
goog.exportSymbol('proto.iotextypes.Log', null, global);
goog.exportSymbol('proto.iotextypes.Logs', null, global);
goog.exportSymbol('proto.iotextypes.MerkleRoot', null, global);
goog.exportSymbol('proto.iotextypes.PlumChallengeExit', null, global);
goog.exportSymbol('proto.iotextypes.PlumCreateDeposit', null, global);
goog.exportSymbol('proto.iotextypes.PlumFinalizeExit', null, global);
goog.exportSymbol('proto.iotextypes.PlumPutBlock', null, global);
goog.exportSymbol('proto.iotextypes.PlumResponseChallengeExit', null, global);
goog.exportSymbol('proto.iotextypes.PlumSettleDeposit', null, global);
goog.exportSymbol('proto.iotextypes.PlumStartExit', null, global);
goog.exportSymbol('proto.iotextypes.PlumTransfer', null, global);
goog.exportSymbol('proto.iotextypes.PutBlock', null, global);
goog.exportSymbol('proto.iotextypes.PutPollResult', null, global);
goog.exportSymbol('proto.iotextypes.Receipt', null, global);
goog.exportSymbol('proto.iotextypes.RewardType', null, global);
goog.exportSymbol('proto.iotextypes.SettleDeposit', null, global);
goog.exportSymbol('proto.iotextypes.StakeAddDeposit', null, global);
goog.exportSymbol('proto.iotextypes.StakeChangeCandidate', null, global);
goog.exportSymbol('proto.iotextypes.StakeCreate', null, global);
goog.exportSymbol('proto.iotextypes.StakeReclaim', null, global);
goog.exportSymbol('proto.iotextypes.StakeRestake', null, global);
goog.exportSymbol('proto.iotextypes.StakeTransferOwnership', null, global);
goog.exportSymbol('proto.iotextypes.StartSubChain', null, global);
goog.exportSymbol('proto.iotextypes.StopSubChain', null, global);
goog.exportSymbol('proto.iotextypes.TerminatePlumChain', null, global);
goog.exportSymbol('proto.iotextypes.Transfer', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.Transfer = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.Transfer, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.Transfer.displayName = 'proto.iotextypes.Transfer';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.Candidate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.Candidate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.Candidate.displayName = 'proto.iotextypes.Candidate';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.CandidateList = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.iotextypes.CandidateList.repeatedFields_, null);
};
goog.inherits(proto.iotextypes.CandidateList, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.CandidateList.displayName = 'proto.iotextypes.CandidateList';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.PutPollResult = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.PutPollResult, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.PutPollResult.displayName = 'proto.iotextypes.PutPollResult';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.Execution = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.iotextypes.Execution.repeatedFields_, null);
};
goog.inherits(proto.iotextypes.Execution, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.Execution.displayName = 'proto.iotextypes.Execution';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.AccessTuple = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.iotextypes.AccessTuple.repeatedFields_, null);
};
goog.inherits(proto.iotextypes.AccessTuple, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.AccessTuple.displayName = 'proto.iotextypes.AccessTuple';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.StakeCreate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.StakeCreate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.StakeCreate.displayName = 'proto.iotextypes.StakeCreate';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.StakeReclaim = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.StakeReclaim, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.StakeReclaim.displayName = 'proto.iotextypes.StakeReclaim';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.StakeAddDeposit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.StakeAddDeposit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.StakeAddDeposit.displayName = 'proto.iotextypes.StakeAddDeposit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.StakeRestake = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.StakeRestake, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.StakeRestake.displayName = 'proto.iotextypes.StakeRestake';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.StakeChangeCandidate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.StakeChangeCandidate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.StakeChangeCandidate.displayName = 'proto.iotextypes.StakeChangeCandidate';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.StakeTransferOwnership = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.StakeTransferOwnership, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.StakeTransferOwnership.displayName = 'proto.iotextypes.StakeTransferOwnership';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.CandidateBasicInfo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.CandidateBasicInfo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.CandidateBasicInfo.displayName = 'proto.iotextypes.CandidateBasicInfo';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.CandidateRegister = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.CandidateRegister, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.CandidateRegister.displayName = 'proto.iotextypes.CandidateRegister';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.StartSubChain = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.StartSubChain, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.StartSubChain.displayName = 'proto.iotextypes.StartSubChain';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.StopSubChain = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.StopSubChain, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.StopSubChain.displayName = 'proto.iotextypes.StopSubChain';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.MerkleRoot = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.MerkleRoot, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.MerkleRoot.displayName = 'proto.iotextypes.MerkleRoot';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.PutBlock = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.iotextypes.PutBlock.repeatedFields_, null);
};
goog.inherits(proto.iotextypes.PutBlock, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.PutBlock.displayName = 'proto.iotextypes.PutBlock';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.CreateDeposit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.CreateDeposit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.CreateDeposit.displayName = 'proto.iotextypes.CreateDeposit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.SettleDeposit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.SettleDeposit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.SettleDeposit.displayName = 'proto.iotextypes.SettleDeposit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.CreatePlumChain = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.CreatePlumChain, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.CreatePlumChain.displayName = 'proto.iotextypes.CreatePlumChain';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.TerminatePlumChain = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.TerminatePlumChain, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.TerminatePlumChain.displayName = 'proto.iotextypes.TerminatePlumChain';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.PlumPutBlock = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.PlumPutBlock, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.PlumPutBlock.displayName = 'proto.iotextypes.PlumPutBlock';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.PlumCreateDeposit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.PlumCreateDeposit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.PlumCreateDeposit.displayName = 'proto.iotextypes.PlumCreateDeposit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.PlumStartExit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.PlumStartExit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.PlumStartExit.displayName = 'proto.iotextypes.PlumStartExit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.PlumChallengeExit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.PlumChallengeExit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.PlumChallengeExit.displayName = 'proto.iotextypes.PlumChallengeExit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.PlumResponseChallengeExit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.PlumResponseChallengeExit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.PlumResponseChallengeExit.displayName = 'proto.iotextypes.PlumResponseChallengeExit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.PlumFinalizeExit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.PlumFinalizeExit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.PlumFinalizeExit.displayName = 'proto.iotextypes.PlumFinalizeExit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.PlumSettleDeposit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.PlumSettleDeposit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.PlumSettleDeposit.displayName = 'proto.iotextypes.PlumSettleDeposit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.PlumTransfer = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.PlumTransfer, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.PlumTransfer.displayName = 'proto.iotextypes.PlumTransfer';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.ActionCore = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.iotextypes.ActionCore.oneofGroups_);
};
goog.inherits(proto.iotextypes.ActionCore, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.ActionCore.displayName = 'proto.iotextypes.ActionCore';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.Action = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.Action, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.Action.displayName = 'proto.iotextypes.Action';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.Receipt = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.iotextypes.Receipt.repeatedFields_, null);
};
goog.inherits(proto.iotextypes.Receipt, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.Receipt.displayName = 'proto.iotextypes.Receipt';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.Log = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.iotextypes.Log.repeatedFields_, null);
};
goog.inherits(proto.iotextypes.Log, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.Log.displayName = 'proto.iotextypes.Log';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.Logs = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.iotextypes.Logs.repeatedFields_, null);
};
goog.inherits(proto.iotextypes.Logs, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.Logs.displayName = 'proto.iotextypes.Logs';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.EvmTransfer = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.EvmTransfer, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.EvmTransfer.displayName = 'proto.iotextypes.EvmTransfer';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.EvmTransferList = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.iotextypes.EvmTransferList.repeatedFields_, null);
};
goog.inherits(proto.iotextypes.EvmTransferList, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.EvmTransferList.displayName = 'proto.iotextypes.EvmTransferList';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.ActionEvmTransfer = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.iotextypes.ActionEvmTransfer.repeatedFields_, null);
};
goog.inherits(proto.iotextypes.ActionEvmTransfer, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.ActionEvmTransfer.displayName = 'proto.iotextypes.ActionEvmTransfer';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.BlockEvmTransfer = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.iotextypes.BlockEvmTransfer.repeatedFields_, null);
};
goog.inherits(proto.iotextypes.BlockEvmTransfer, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.BlockEvmTransfer.displayName = 'proto.iotextypes.BlockEvmTransfer';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.DepositToRewardingFund = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.DepositToRewardingFund, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.DepositToRewardingFund.displayName = 'proto.iotextypes.DepositToRewardingFund';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.ClaimFromRewardingFund = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.ClaimFromRewardingFund, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.ClaimFromRewardingFund.displayName = 'proto.iotextypes.ClaimFromRewardingFund';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.iotextypes.GrantReward = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.iotextypes.GrantReward, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.iotextypes.GrantReward.displayName = 'proto.iotextypes.GrantReward';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.Transfer.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.Transfer.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.Transfer} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.Transfer.toObject = function(includeInstance, msg) {
  var f, obj = {
    amount: jspb.Message.getFieldWithDefault(msg, 1, ""),
    recipient: jspb.Message.getFieldWithDefault(msg, 2, ""),
    payload: msg.getPayload_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.Transfer}
 */
proto.iotextypes.Transfer.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.Transfer;
  return proto.iotextypes.Transfer.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.Transfer} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.Transfer}
 */
proto.iotextypes.Transfer.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setRecipient(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPayload(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.Transfer.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.Transfer.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.Transfer} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.Transfer.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getRecipient();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getPayload_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional string amount = 1;
 * @return {string}
 */
proto.iotextypes.Transfer.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.Transfer} returns this
 */
proto.iotextypes.Transfer.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string recipient = 2;
 * @return {string}
 */
proto.iotextypes.Transfer.prototype.getRecipient = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.Transfer} returns this
 */
proto.iotextypes.Transfer.prototype.setRecipient = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional bytes payload = 3;
 * @return {string}
 */
proto.iotextypes.Transfer.prototype.getPayload = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes payload = 3;
 * This is a type-conversion wrapper around `getPayload()`
 * @return {string}
 */
proto.iotextypes.Transfer.prototype.getPayload_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPayload()));
};


/**
 * optional bytes payload = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPayload()`
 * @return {!Uint8Array}
 */
proto.iotextypes.Transfer.prototype.getPayload_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPayload()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.Transfer} returns this
 */
proto.iotextypes.Transfer.prototype.setPayload = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.Candidate.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.Candidate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.Candidate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.Candidate.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getFieldWithDefault(msg, 1, ""),
    votes: msg.getVotes_asB64(),
    pubkey: msg.getPubkey_asB64(),
    rewardaddress: jspb.Message.getFieldWithDefault(msg, 4, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.Candidate}
 */
proto.iotextypes.Candidate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.Candidate;
  return proto.iotextypes.Candidate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.Candidate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.Candidate}
 */
proto.iotextypes.Candidate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setVotes(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPubkey(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setRewardaddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.Candidate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.Candidate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.Candidate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.Candidate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getVotes_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getPubkey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getRewardaddress();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.iotextypes.Candidate.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.Candidate} returns this
 */
proto.iotextypes.Candidate.prototype.setAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional bytes votes = 2;
 * @return {string}
 */
proto.iotextypes.Candidate.prototype.getVotes = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes votes = 2;
 * This is a type-conversion wrapper around `getVotes()`
 * @return {string}
 */
proto.iotextypes.Candidate.prototype.getVotes_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getVotes()));
};


/**
 * optional bytes votes = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getVotes()`
 * @return {!Uint8Array}
 */
proto.iotextypes.Candidate.prototype.getVotes_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getVotes()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.Candidate} returns this
 */
proto.iotextypes.Candidate.prototype.setVotes = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional bytes pubKey = 3;
 * @return {string}
 */
proto.iotextypes.Candidate.prototype.getPubkey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes pubKey = 3;
 * This is a type-conversion wrapper around `getPubkey()`
 * @return {string}
 */
proto.iotextypes.Candidate.prototype.getPubkey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPubkey()));
};


/**
 * optional bytes pubKey = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPubkey()`
 * @return {!Uint8Array}
 */
proto.iotextypes.Candidate.prototype.getPubkey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPubkey()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.Candidate} returns this
 */
proto.iotextypes.Candidate.prototype.setPubkey = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional string rewardAddress = 4;
 * @return {string}
 */
proto.iotextypes.Candidate.prototype.getRewardaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.Candidate} returns this
 */
proto.iotextypes.Candidate.prototype.setRewardaddress = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.iotextypes.CandidateList.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.CandidateList.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.CandidateList.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.CandidateList} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.CandidateList.toObject = function(includeInstance, msg) {
  var f, obj = {
    candidatesList: jspb.Message.toObjectList(msg.getCandidatesList(),
    proto.iotextypes.Candidate.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.CandidateList}
 */
proto.iotextypes.CandidateList.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.CandidateList;
  return proto.iotextypes.CandidateList.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.CandidateList} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.CandidateList}
 */
proto.iotextypes.CandidateList.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.iotextypes.Candidate;
      reader.readMessage(value,proto.iotextypes.Candidate.deserializeBinaryFromReader);
      msg.addCandidates(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.CandidateList.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.CandidateList.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.CandidateList} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.CandidateList.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCandidatesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.iotextypes.Candidate.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Candidate candidates = 1;
 * @return {!Array<!proto.iotextypes.Candidate>}
 */
proto.iotextypes.CandidateList.prototype.getCandidatesList = function() {
  return /** @type{!Array<!proto.iotextypes.Candidate>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.iotextypes.Candidate, 1));
};


/**
 * @param {!Array<!proto.iotextypes.Candidate>} value
 * @return {!proto.iotextypes.CandidateList} returns this
*/
proto.iotextypes.CandidateList.prototype.setCandidatesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.iotextypes.Candidate=} opt_value
 * @param {number=} opt_index
 * @return {!proto.iotextypes.Candidate}
 */
proto.iotextypes.CandidateList.prototype.addCandidates = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.iotextypes.Candidate, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.iotextypes.CandidateList} returns this
 */
proto.iotextypes.CandidateList.prototype.clearCandidatesList = function() {
  return this.setCandidatesList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.PutPollResult.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.PutPollResult.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.PutPollResult} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PutPollResult.toObject = function(includeInstance, msg) {
  var f, obj = {
    height: jspb.Message.getFieldWithDefault(msg, 1, 0),
    candidates: (f = msg.getCandidates()) && proto.iotextypes.CandidateList.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.PutPollResult}
 */
proto.iotextypes.PutPollResult.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.PutPollResult;
  return proto.iotextypes.PutPollResult.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.PutPollResult} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.PutPollResult}
 */
proto.iotextypes.PutPollResult.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setHeight(value);
      break;
    case 2:
      var value = new proto.iotextypes.CandidateList;
      reader.readMessage(value,proto.iotextypes.CandidateList.deserializeBinaryFromReader);
      msg.setCandidates(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.PutPollResult.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.PutPollResult.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.PutPollResult} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PutPollResult.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHeight();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getCandidates();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.iotextypes.CandidateList.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 height = 1;
 * @return {number}
 */
proto.iotextypes.PutPollResult.prototype.getHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.PutPollResult} returns this
 */
proto.iotextypes.PutPollResult.prototype.setHeight = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional CandidateList candidates = 2;
 * @return {?proto.iotextypes.CandidateList}
 */
proto.iotextypes.PutPollResult.prototype.getCandidates = function() {
  return /** @type{?proto.iotextypes.CandidateList} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.CandidateList, 2));
};


/**
 * @param {?proto.iotextypes.CandidateList|undefined} value
 * @return {!proto.iotextypes.PutPollResult} returns this
*/
proto.iotextypes.PutPollResult.prototype.setCandidates = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.PutPollResult} returns this
 */
proto.iotextypes.PutPollResult.prototype.clearCandidates = function() {
  return this.setCandidates(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.PutPollResult.prototype.hasCandidates = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.iotextypes.Execution.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.Execution.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.Execution.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.Execution} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.Execution.toObject = function(includeInstance, msg) {
  var f, obj = {
    amount: jspb.Message.getFieldWithDefault(msg, 1, ""),
    contract: jspb.Message.getFieldWithDefault(msg, 2, ""),
    data: msg.getData_asB64(),
    accesslistList: jspb.Message.toObjectList(msg.getAccesslistList(),
    proto.iotextypes.AccessTuple.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.Execution}
 */
proto.iotextypes.Execution.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.Execution;
  return proto.iotextypes.Execution.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.Execution} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.Execution}
 */
proto.iotextypes.Execution.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setContract(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setData(value);
      break;
    case 4:
      var value = new proto.iotextypes.AccessTuple;
      reader.readMessage(value,proto.iotextypes.AccessTuple.deserializeBinaryFromReader);
      msg.addAccesslist(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.Execution.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.Execution.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.Execution} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.Execution.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getContract();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getData_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getAccesslistList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.iotextypes.AccessTuple.serializeBinaryToWriter
    );
  }
};


/**
 * optional string amount = 1;
 * @return {string}
 */
proto.iotextypes.Execution.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.Execution} returns this
 */
proto.iotextypes.Execution.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string contract = 2;
 * @return {string}
 */
proto.iotextypes.Execution.prototype.getContract = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.Execution} returns this
 */
proto.iotextypes.Execution.prototype.setContract = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional bytes data = 3;
 * @return {string}
 */
proto.iotextypes.Execution.prototype.getData = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes data = 3;
 * This is a type-conversion wrapper around `getData()`
 * @return {string}
 */
proto.iotextypes.Execution.prototype.getData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getData()));
};


/**
 * optional bytes data = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getData()`
 * @return {!Uint8Array}
 */
proto.iotextypes.Execution.prototype.getData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getData()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.Execution} returns this
 */
proto.iotextypes.Execution.prototype.setData = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * repeated AccessTuple accessList = 4;
 * @return {!Array<!proto.iotextypes.AccessTuple>}
 */
proto.iotextypes.Execution.prototype.getAccesslistList = function() {
  return /** @type{!Array<!proto.iotextypes.AccessTuple>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.iotextypes.AccessTuple, 4));
};


/**
 * @param {!Array<!proto.iotextypes.AccessTuple>} value
 * @return {!proto.iotextypes.Execution} returns this
*/
proto.iotextypes.Execution.prototype.setAccesslistList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.iotextypes.AccessTuple=} opt_value
 * @param {number=} opt_index
 * @return {!proto.iotextypes.AccessTuple}
 */
proto.iotextypes.Execution.prototype.addAccesslist = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.iotextypes.AccessTuple, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.iotextypes.Execution} returns this
 */
proto.iotextypes.Execution.prototype.clearAccesslistList = function() {
  return this.setAccesslistList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.iotextypes.AccessTuple.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.AccessTuple.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.AccessTuple.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.AccessTuple} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.AccessTuple.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getFieldWithDefault(msg, 1, ""),
    storagekeysList: (f = jspb.Message.getRepeatedField(msg, 2)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.AccessTuple}
 */
proto.iotextypes.AccessTuple.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.AccessTuple;
  return proto.iotextypes.AccessTuple.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.AccessTuple} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.AccessTuple}
 */
proto.iotextypes.AccessTuple.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.addStoragekeys(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.AccessTuple.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.AccessTuple.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.AccessTuple} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.AccessTuple.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getStoragekeysList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      2,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.iotextypes.AccessTuple.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.AccessTuple} returns this
 */
proto.iotextypes.AccessTuple.prototype.setAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * repeated string storageKeys = 2;
 * @return {!Array<string>}
 */
proto.iotextypes.AccessTuple.prototype.getStoragekeysList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 2));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.iotextypes.AccessTuple} returns this
 */
proto.iotextypes.AccessTuple.prototype.setStoragekeysList = function(value) {
  return jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.iotextypes.AccessTuple} returns this
 */
proto.iotextypes.AccessTuple.prototype.addStoragekeys = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.iotextypes.AccessTuple} returns this
 */
proto.iotextypes.AccessTuple.prototype.clearStoragekeysList = function() {
  return this.setStoragekeysList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.StakeCreate.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.StakeCreate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.StakeCreate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StakeCreate.toObject = function(includeInstance, msg) {
  var f, obj = {
    candidatename: jspb.Message.getFieldWithDefault(msg, 1, ""),
    stakedamount: jspb.Message.getFieldWithDefault(msg, 2, ""),
    stakedduration: jspb.Message.getFieldWithDefault(msg, 3, 0),
    autostake: jspb.Message.getBooleanFieldWithDefault(msg, 4, false),
    payload: msg.getPayload_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.StakeCreate}
 */
proto.iotextypes.StakeCreate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.StakeCreate;
  return proto.iotextypes.StakeCreate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.StakeCreate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.StakeCreate}
 */
proto.iotextypes.StakeCreate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setCandidatename(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setStakedamount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setStakedduration(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAutostake(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPayload(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.StakeCreate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.StakeCreate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.StakeCreate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StakeCreate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCandidatename();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getStakedamount();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getStakedduration();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getAutostake();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = message.getPayload_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
};


/**
 * optional string candidateName = 1;
 * @return {string}
 */
proto.iotextypes.StakeCreate.prototype.getCandidatename = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.StakeCreate} returns this
 */
proto.iotextypes.StakeCreate.prototype.setCandidatename = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string stakedAmount = 2;
 * @return {string}
 */
proto.iotextypes.StakeCreate.prototype.getStakedamount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.StakeCreate} returns this
 */
proto.iotextypes.StakeCreate.prototype.setStakedamount = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional uint32 stakedDuration = 3;
 * @return {number}
 */
proto.iotextypes.StakeCreate.prototype.getStakedduration = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.StakeCreate} returns this
 */
proto.iotextypes.StakeCreate.prototype.setStakedduration = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional bool autoStake = 4;
 * @return {boolean}
 */
proto.iotextypes.StakeCreate.prototype.getAutostake = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 4, false));
};


/**
 * @param {boolean} value
 * @return {!proto.iotextypes.StakeCreate} returns this
 */
proto.iotextypes.StakeCreate.prototype.setAutostake = function(value) {
  return jspb.Message.setProto3BooleanField(this, 4, value);
};


/**
 * optional bytes payload = 5;
 * @return {string}
 */
proto.iotextypes.StakeCreate.prototype.getPayload = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes payload = 5;
 * This is a type-conversion wrapper around `getPayload()`
 * @return {string}
 */
proto.iotextypes.StakeCreate.prototype.getPayload_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPayload()));
};


/**
 * optional bytes payload = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPayload()`
 * @return {!Uint8Array}
 */
proto.iotextypes.StakeCreate.prototype.getPayload_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPayload()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.StakeCreate} returns this
 */
proto.iotextypes.StakeCreate.prototype.setPayload = function(value) {
  return jspb.Message.setProto3BytesField(this, 5, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.StakeReclaim.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.StakeReclaim.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.StakeReclaim} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StakeReclaim.toObject = function(includeInstance, msg) {
  var f, obj = {
    bucketindex: jspb.Message.getFieldWithDefault(msg, 1, 0),
    payload: msg.getPayload_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.StakeReclaim}
 */
proto.iotextypes.StakeReclaim.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.StakeReclaim;
  return proto.iotextypes.StakeReclaim.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.StakeReclaim} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.StakeReclaim}
 */
proto.iotextypes.StakeReclaim.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setBucketindex(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPayload(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.StakeReclaim.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.StakeReclaim.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.StakeReclaim} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StakeReclaim.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBucketindex();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getPayload_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional uint64 bucketIndex = 1;
 * @return {number}
 */
proto.iotextypes.StakeReclaim.prototype.getBucketindex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.StakeReclaim} returns this
 */
proto.iotextypes.StakeReclaim.prototype.setBucketindex = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional bytes payload = 2;
 * @return {string}
 */
proto.iotextypes.StakeReclaim.prototype.getPayload = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes payload = 2;
 * This is a type-conversion wrapper around `getPayload()`
 * @return {string}
 */
proto.iotextypes.StakeReclaim.prototype.getPayload_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPayload()));
};


/**
 * optional bytes payload = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPayload()`
 * @return {!Uint8Array}
 */
proto.iotextypes.StakeReclaim.prototype.getPayload_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPayload()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.StakeReclaim} returns this
 */
proto.iotextypes.StakeReclaim.prototype.setPayload = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.StakeAddDeposit.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.StakeAddDeposit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.StakeAddDeposit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StakeAddDeposit.toObject = function(includeInstance, msg) {
  var f, obj = {
    bucketindex: jspb.Message.getFieldWithDefault(msg, 1, 0),
    amount: jspb.Message.getFieldWithDefault(msg, 2, ""),
    payload: msg.getPayload_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.StakeAddDeposit}
 */
proto.iotextypes.StakeAddDeposit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.StakeAddDeposit;
  return proto.iotextypes.StakeAddDeposit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.StakeAddDeposit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.StakeAddDeposit}
 */
proto.iotextypes.StakeAddDeposit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setBucketindex(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPayload(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.StakeAddDeposit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.StakeAddDeposit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.StakeAddDeposit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StakeAddDeposit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBucketindex();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getPayload_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional uint64 bucketIndex = 1;
 * @return {number}
 */
proto.iotextypes.StakeAddDeposit.prototype.getBucketindex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.StakeAddDeposit} returns this
 */
proto.iotextypes.StakeAddDeposit.prototype.setBucketindex = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string amount = 2;
 * @return {string}
 */
proto.iotextypes.StakeAddDeposit.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.StakeAddDeposit} returns this
 */
proto.iotextypes.StakeAddDeposit.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional bytes payload = 3;
 * @return {string}
 */
proto.iotextypes.StakeAddDeposit.prototype.getPayload = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes payload = 3;
 * This is a type-conversion wrapper around `getPayload()`
 * @return {string}
 */
proto.iotextypes.StakeAddDeposit.prototype.getPayload_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPayload()));
};


/**
 * optional bytes payload = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPayload()`
 * @return {!Uint8Array}
 */
proto.iotextypes.StakeAddDeposit.prototype.getPayload_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPayload()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.StakeAddDeposit} returns this
 */
proto.iotextypes.StakeAddDeposit.prototype.setPayload = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.StakeRestake.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.StakeRestake.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.StakeRestake} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StakeRestake.toObject = function(includeInstance, msg) {
  var f, obj = {
    bucketindex: jspb.Message.getFieldWithDefault(msg, 1, 0),
    stakedduration: jspb.Message.getFieldWithDefault(msg, 2, 0),
    autostake: jspb.Message.getBooleanFieldWithDefault(msg, 3, false),
    payload: msg.getPayload_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.StakeRestake}
 */
proto.iotextypes.StakeRestake.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.StakeRestake;
  return proto.iotextypes.StakeRestake.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.StakeRestake} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.StakeRestake}
 */
proto.iotextypes.StakeRestake.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setBucketindex(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setStakedduration(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAutostake(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPayload(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.StakeRestake.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.StakeRestake.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.StakeRestake} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StakeRestake.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBucketindex();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getStakedduration();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getAutostake();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getPayload_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * optional uint64 bucketIndex = 1;
 * @return {number}
 */
proto.iotextypes.StakeRestake.prototype.getBucketindex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.StakeRestake} returns this
 */
proto.iotextypes.StakeRestake.prototype.setBucketindex = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint32 stakedDuration = 2;
 * @return {number}
 */
proto.iotextypes.StakeRestake.prototype.getStakedduration = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.StakeRestake} returns this
 */
proto.iotextypes.StakeRestake.prototype.setStakedduration = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bool autoStake = 3;
 * @return {boolean}
 */
proto.iotextypes.StakeRestake.prototype.getAutostake = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 3, false));
};


/**
 * @param {boolean} value
 * @return {!proto.iotextypes.StakeRestake} returns this
 */
proto.iotextypes.StakeRestake.prototype.setAutostake = function(value) {
  return jspb.Message.setProto3BooleanField(this, 3, value);
};


/**
 * optional bytes payload = 4;
 * @return {string}
 */
proto.iotextypes.StakeRestake.prototype.getPayload = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes payload = 4;
 * This is a type-conversion wrapper around `getPayload()`
 * @return {string}
 */
proto.iotextypes.StakeRestake.prototype.getPayload_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPayload()));
};


/**
 * optional bytes payload = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPayload()`
 * @return {!Uint8Array}
 */
proto.iotextypes.StakeRestake.prototype.getPayload_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPayload()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.StakeRestake} returns this
 */
proto.iotextypes.StakeRestake.prototype.setPayload = function(value) {
  return jspb.Message.setProto3BytesField(this, 4, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.StakeChangeCandidate.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.StakeChangeCandidate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.StakeChangeCandidate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StakeChangeCandidate.toObject = function(includeInstance, msg) {
  var f, obj = {
    bucketindex: jspb.Message.getFieldWithDefault(msg, 1, 0),
    candidatename: jspb.Message.getFieldWithDefault(msg, 2, ""),
    payload: msg.getPayload_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.StakeChangeCandidate}
 */
proto.iotextypes.StakeChangeCandidate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.StakeChangeCandidate;
  return proto.iotextypes.StakeChangeCandidate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.StakeChangeCandidate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.StakeChangeCandidate}
 */
proto.iotextypes.StakeChangeCandidate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setBucketindex(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setCandidatename(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPayload(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.StakeChangeCandidate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.StakeChangeCandidate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.StakeChangeCandidate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StakeChangeCandidate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBucketindex();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getCandidatename();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getPayload_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional uint64 bucketIndex = 1;
 * @return {number}
 */
proto.iotextypes.StakeChangeCandidate.prototype.getBucketindex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.StakeChangeCandidate} returns this
 */
proto.iotextypes.StakeChangeCandidate.prototype.setBucketindex = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string candidateName = 2;
 * @return {string}
 */
proto.iotextypes.StakeChangeCandidate.prototype.getCandidatename = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.StakeChangeCandidate} returns this
 */
proto.iotextypes.StakeChangeCandidate.prototype.setCandidatename = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional bytes payload = 3;
 * @return {string}
 */
proto.iotextypes.StakeChangeCandidate.prototype.getPayload = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes payload = 3;
 * This is a type-conversion wrapper around `getPayload()`
 * @return {string}
 */
proto.iotextypes.StakeChangeCandidate.prototype.getPayload_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPayload()));
};


/**
 * optional bytes payload = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPayload()`
 * @return {!Uint8Array}
 */
proto.iotextypes.StakeChangeCandidate.prototype.getPayload_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPayload()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.StakeChangeCandidate} returns this
 */
proto.iotextypes.StakeChangeCandidate.prototype.setPayload = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.StakeTransferOwnership.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.StakeTransferOwnership.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.StakeTransferOwnership} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StakeTransferOwnership.toObject = function(includeInstance, msg) {
  var f, obj = {
    bucketindex: jspb.Message.getFieldWithDefault(msg, 1, 0),
    voteraddress: jspb.Message.getFieldWithDefault(msg, 2, ""),
    payload: msg.getPayload_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.StakeTransferOwnership}
 */
proto.iotextypes.StakeTransferOwnership.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.StakeTransferOwnership;
  return proto.iotextypes.StakeTransferOwnership.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.StakeTransferOwnership} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.StakeTransferOwnership}
 */
proto.iotextypes.StakeTransferOwnership.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setBucketindex(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setVoteraddress(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPayload(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.StakeTransferOwnership.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.StakeTransferOwnership.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.StakeTransferOwnership} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StakeTransferOwnership.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBucketindex();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getVoteraddress();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getPayload_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional uint64 bucketIndex = 1;
 * @return {number}
 */
proto.iotextypes.StakeTransferOwnership.prototype.getBucketindex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.StakeTransferOwnership} returns this
 */
proto.iotextypes.StakeTransferOwnership.prototype.setBucketindex = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string voterAddress = 2;
 * @return {string}
 */
proto.iotextypes.StakeTransferOwnership.prototype.getVoteraddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.StakeTransferOwnership} returns this
 */
proto.iotextypes.StakeTransferOwnership.prototype.setVoteraddress = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional bytes payload = 3;
 * @return {string}
 */
proto.iotextypes.StakeTransferOwnership.prototype.getPayload = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes payload = 3;
 * This is a type-conversion wrapper around `getPayload()`
 * @return {string}
 */
proto.iotextypes.StakeTransferOwnership.prototype.getPayload_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPayload()));
};


/**
 * optional bytes payload = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPayload()`
 * @return {!Uint8Array}
 */
proto.iotextypes.StakeTransferOwnership.prototype.getPayload_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPayload()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.StakeTransferOwnership} returns this
 */
proto.iotextypes.StakeTransferOwnership.prototype.setPayload = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.CandidateBasicInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.CandidateBasicInfo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.CandidateBasicInfo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.CandidateBasicInfo.toObject = function(includeInstance, msg) {
  var f, obj = {
    name: jspb.Message.getFieldWithDefault(msg, 1, ""),
    operatoraddress: jspb.Message.getFieldWithDefault(msg, 2, ""),
    rewardaddress: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.CandidateBasicInfo}
 */
proto.iotextypes.CandidateBasicInfo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.CandidateBasicInfo;
  return proto.iotextypes.CandidateBasicInfo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.CandidateBasicInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.CandidateBasicInfo}
 */
proto.iotextypes.CandidateBasicInfo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setOperatoraddress(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setRewardaddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.CandidateBasicInfo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.CandidateBasicInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.CandidateBasicInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.CandidateBasicInfo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getOperatoraddress();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getRewardaddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional string name = 1;
 * @return {string}
 */
proto.iotextypes.CandidateBasicInfo.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.CandidateBasicInfo} returns this
 */
proto.iotextypes.CandidateBasicInfo.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string operatorAddress = 2;
 * @return {string}
 */
proto.iotextypes.CandidateBasicInfo.prototype.getOperatoraddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.CandidateBasicInfo} returns this
 */
proto.iotextypes.CandidateBasicInfo.prototype.setOperatoraddress = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string rewardAddress = 3;
 * @return {string}
 */
proto.iotextypes.CandidateBasicInfo.prototype.getRewardaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.CandidateBasicInfo} returns this
 */
proto.iotextypes.CandidateBasicInfo.prototype.setRewardaddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.CandidateRegister.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.CandidateRegister.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.CandidateRegister} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.CandidateRegister.toObject = function(includeInstance, msg) {
  var f, obj = {
    candidate: (f = msg.getCandidate()) && proto.iotextypes.CandidateBasicInfo.toObject(includeInstance, f),
    stakedamount: jspb.Message.getFieldWithDefault(msg, 2, ""),
    stakedduration: jspb.Message.getFieldWithDefault(msg, 3, 0),
    autostake: jspb.Message.getBooleanFieldWithDefault(msg, 4, false),
    owneraddress: jspb.Message.getFieldWithDefault(msg, 5, ""),
    payload: msg.getPayload_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.CandidateRegister}
 */
proto.iotextypes.CandidateRegister.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.CandidateRegister;
  return proto.iotextypes.CandidateRegister.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.CandidateRegister} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.CandidateRegister}
 */
proto.iotextypes.CandidateRegister.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.iotextypes.CandidateBasicInfo;
      reader.readMessage(value,proto.iotextypes.CandidateBasicInfo.deserializeBinaryFromReader);
      msg.setCandidate(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setStakedamount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setStakedduration(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAutostake(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setOwneraddress(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPayload(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.CandidateRegister.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.CandidateRegister.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.CandidateRegister} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.CandidateRegister.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCandidate();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.iotextypes.CandidateBasicInfo.serializeBinaryToWriter
    );
  }
  f = message.getStakedamount();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getStakedduration();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getAutostake();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = message.getOwneraddress();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getPayload_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      6,
      f
    );
  }
};


/**
 * optional CandidateBasicInfo candidate = 1;
 * @return {?proto.iotextypes.CandidateBasicInfo}
 */
proto.iotextypes.CandidateRegister.prototype.getCandidate = function() {
  return /** @type{?proto.iotextypes.CandidateBasicInfo} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.CandidateBasicInfo, 1));
};


/**
 * @param {?proto.iotextypes.CandidateBasicInfo|undefined} value
 * @return {!proto.iotextypes.CandidateRegister} returns this
*/
proto.iotextypes.CandidateRegister.prototype.setCandidate = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.CandidateRegister} returns this
 */
proto.iotextypes.CandidateRegister.prototype.clearCandidate = function() {
  return this.setCandidate(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.CandidateRegister.prototype.hasCandidate = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string stakedAmount = 2;
 * @return {string}
 */
proto.iotextypes.CandidateRegister.prototype.getStakedamount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.CandidateRegister} returns this
 */
proto.iotextypes.CandidateRegister.prototype.setStakedamount = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional uint32 stakedDuration = 3;
 * @return {number}
 */
proto.iotextypes.CandidateRegister.prototype.getStakedduration = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.CandidateRegister} returns this
 */
proto.iotextypes.CandidateRegister.prototype.setStakedduration = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional bool autoStake = 4;
 * @return {boolean}
 */
proto.iotextypes.CandidateRegister.prototype.getAutostake = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 4, false));
};


/**
 * @param {boolean} value
 * @return {!proto.iotextypes.CandidateRegister} returns this
 */
proto.iotextypes.CandidateRegister.prototype.setAutostake = function(value) {
  return jspb.Message.setProto3BooleanField(this, 4, value);
};


/**
 * optional string ownerAddress = 5;
 * @return {string}
 */
proto.iotextypes.CandidateRegister.prototype.getOwneraddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.CandidateRegister} returns this
 */
proto.iotextypes.CandidateRegister.prototype.setOwneraddress = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};


/**
 * optional bytes payload = 6;
 * @return {string}
 */
proto.iotextypes.CandidateRegister.prototype.getPayload = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * optional bytes payload = 6;
 * This is a type-conversion wrapper around `getPayload()`
 * @return {string}
 */
proto.iotextypes.CandidateRegister.prototype.getPayload_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPayload()));
};


/**
 * optional bytes payload = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPayload()`
 * @return {!Uint8Array}
 */
proto.iotextypes.CandidateRegister.prototype.getPayload_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPayload()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.CandidateRegister} returns this
 */
proto.iotextypes.CandidateRegister.prototype.setPayload = function(value) {
  return jspb.Message.setProto3BytesField(this, 6, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.StartSubChain.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.StartSubChain.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.StartSubChain} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StartSubChain.toObject = function(includeInstance, msg) {
  var f, obj = {
    chainid: jspb.Message.getFieldWithDefault(msg, 1, 0),
    securitydeposit: jspb.Message.getFieldWithDefault(msg, 2, ""),
    operationdeposit: jspb.Message.getFieldWithDefault(msg, 3, ""),
    startheight: jspb.Message.getFieldWithDefault(msg, 4, 0),
    parentheightoffset: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.StartSubChain}
 */
proto.iotextypes.StartSubChain.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.StartSubChain;
  return proto.iotextypes.StartSubChain.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.StartSubChain} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.StartSubChain}
 */
proto.iotextypes.StartSubChain.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setChainid(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setSecuritydeposit(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setOperationdeposit(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setStartheight(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setParentheightoffset(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.StartSubChain.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.StartSubChain.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.StartSubChain} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StartSubChain.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChainid();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getSecuritydeposit();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getOperationdeposit();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getStartheight();
  if (f !== 0) {
    writer.writeUint64(
      4,
      f
    );
  }
  f = message.getParentheightoffset();
  if (f !== 0) {
    writer.writeUint64(
      5,
      f
    );
  }
};


/**
 * optional uint32 chainID = 1;
 * @return {number}
 */
proto.iotextypes.StartSubChain.prototype.getChainid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.StartSubChain} returns this
 */
proto.iotextypes.StartSubChain.prototype.setChainid = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string securityDeposit = 2;
 * @return {string}
 */
proto.iotextypes.StartSubChain.prototype.getSecuritydeposit = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.StartSubChain} returns this
 */
proto.iotextypes.StartSubChain.prototype.setSecuritydeposit = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string operationDeposit = 3;
 * @return {string}
 */
proto.iotextypes.StartSubChain.prototype.getOperationdeposit = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.StartSubChain} returns this
 */
proto.iotextypes.StartSubChain.prototype.setOperationdeposit = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional uint64 startHeight = 4;
 * @return {number}
 */
proto.iotextypes.StartSubChain.prototype.getStartheight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.StartSubChain} returns this
 */
proto.iotextypes.StartSubChain.prototype.setStartheight = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional uint64 parentHeightOffset = 5;
 * @return {number}
 */
proto.iotextypes.StartSubChain.prototype.getParentheightoffset = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.StartSubChain} returns this
 */
proto.iotextypes.StartSubChain.prototype.setParentheightoffset = function(value) {
  return jspb.Message.setProto3IntField(this, 5, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.StopSubChain.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.StopSubChain.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.StopSubChain} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StopSubChain.toObject = function(includeInstance, msg) {
  var f, obj = {
    chainid: jspb.Message.getFieldWithDefault(msg, 1, 0),
    stopheight: jspb.Message.getFieldWithDefault(msg, 2, 0),
    subchainaddress: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.StopSubChain}
 */
proto.iotextypes.StopSubChain.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.StopSubChain;
  return proto.iotextypes.StopSubChain.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.StopSubChain} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.StopSubChain}
 */
proto.iotextypes.StopSubChain.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setChainid(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setStopheight(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setSubchainaddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.StopSubChain.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.StopSubChain.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.StopSubChain} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.StopSubChain.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChainid();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getStopheight();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getSubchainaddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional uint32 chainID = 1;
 * @return {number}
 */
proto.iotextypes.StopSubChain.prototype.getChainid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.StopSubChain} returns this
 */
proto.iotextypes.StopSubChain.prototype.setChainid = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 stopHeight = 2;
 * @return {number}
 */
proto.iotextypes.StopSubChain.prototype.getStopheight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.StopSubChain} returns this
 */
proto.iotextypes.StopSubChain.prototype.setStopheight = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string subChainAddress = 3;
 * @return {string}
 */
proto.iotextypes.StopSubChain.prototype.getSubchainaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.StopSubChain} returns this
 */
proto.iotextypes.StopSubChain.prototype.setSubchainaddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.MerkleRoot.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.MerkleRoot.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.MerkleRoot} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.MerkleRoot.toObject = function(includeInstance, msg) {
  var f, obj = {
    name: jspb.Message.getFieldWithDefault(msg, 1, ""),
    value: msg.getValue_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.MerkleRoot}
 */
proto.iotextypes.MerkleRoot.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.MerkleRoot;
  return proto.iotextypes.MerkleRoot.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.MerkleRoot} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.MerkleRoot}
 */
proto.iotextypes.MerkleRoot.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.MerkleRoot.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.MerkleRoot.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.MerkleRoot} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.MerkleRoot.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getValue_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional string name = 1;
 * @return {string}
 */
proto.iotextypes.MerkleRoot.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.MerkleRoot} returns this
 */
proto.iotextypes.MerkleRoot.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional bytes value = 2;
 * @return {string}
 */
proto.iotextypes.MerkleRoot.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes value = 2;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.iotextypes.MerkleRoot.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.iotextypes.MerkleRoot.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.MerkleRoot} returns this
 */
proto.iotextypes.MerkleRoot.prototype.setValue = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.iotextypes.PutBlock.repeatedFields_ = [3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.PutBlock.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.PutBlock.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.PutBlock} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PutBlock.toObject = function(includeInstance, msg) {
  var f, obj = {
    subchainaddress: jspb.Message.getFieldWithDefault(msg, 1, ""),
    height: jspb.Message.getFieldWithDefault(msg, 2, 0),
    rootsList: jspb.Message.toObjectList(msg.getRootsList(),
    proto.iotextypes.MerkleRoot.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.PutBlock}
 */
proto.iotextypes.PutBlock.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.PutBlock;
  return proto.iotextypes.PutBlock.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.PutBlock} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.PutBlock}
 */
proto.iotextypes.PutBlock.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSubchainaddress(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setHeight(value);
      break;
    case 3:
      var value = new proto.iotextypes.MerkleRoot;
      reader.readMessage(value,proto.iotextypes.MerkleRoot.deserializeBinaryFromReader);
      msg.addRoots(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.PutBlock.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.PutBlock.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.PutBlock} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PutBlock.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSubchainaddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getHeight();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getRootsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.iotextypes.MerkleRoot.serializeBinaryToWriter
    );
  }
};


/**
 * optional string subChainAddress = 1;
 * @return {string}
 */
proto.iotextypes.PutBlock.prototype.getSubchainaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.PutBlock} returns this
 */
proto.iotextypes.PutBlock.prototype.setSubchainaddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 height = 2;
 * @return {number}
 */
proto.iotextypes.PutBlock.prototype.getHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.PutBlock} returns this
 */
proto.iotextypes.PutBlock.prototype.setHeight = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * repeated MerkleRoot roots = 3;
 * @return {!Array<!proto.iotextypes.MerkleRoot>}
 */
proto.iotextypes.PutBlock.prototype.getRootsList = function() {
  return /** @type{!Array<!proto.iotextypes.MerkleRoot>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.iotextypes.MerkleRoot, 3));
};


/**
 * @param {!Array<!proto.iotextypes.MerkleRoot>} value
 * @return {!proto.iotextypes.PutBlock} returns this
*/
proto.iotextypes.PutBlock.prototype.setRootsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.iotextypes.MerkleRoot=} opt_value
 * @param {number=} opt_index
 * @return {!proto.iotextypes.MerkleRoot}
 */
proto.iotextypes.PutBlock.prototype.addRoots = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.iotextypes.MerkleRoot, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.iotextypes.PutBlock} returns this
 */
proto.iotextypes.PutBlock.prototype.clearRootsList = function() {
  return this.setRootsList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.CreateDeposit.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.CreateDeposit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.CreateDeposit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.CreateDeposit.toObject = function(includeInstance, msg) {
  var f, obj = {
    chainid: jspb.Message.getFieldWithDefault(msg, 1, 0),
    amount: jspb.Message.getFieldWithDefault(msg, 2, ""),
    recipient: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.CreateDeposit}
 */
proto.iotextypes.CreateDeposit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.CreateDeposit;
  return proto.iotextypes.CreateDeposit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.CreateDeposit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.CreateDeposit}
 */
proto.iotextypes.CreateDeposit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setChainid(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setRecipient(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.CreateDeposit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.CreateDeposit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.CreateDeposit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.CreateDeposit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChainid();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getRecipient();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional uint32 chainID = 1;
 * @return {number}
 */
proto.iotextypes.CreateDeposit.prototype.getChainid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.CreateDeposit} returns this
 */
proto.iotextypes.CreateDeposit.prototype.setChainid = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string amount = 2;
 * @return {string}
 */
proto.iotextypes.CreateDeposit.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.CreateDeposit} returns this
 */
proto.iotextypes.CreateDeposit.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string recipient = 3;
 * @return {string}
 */
proto.iotextypes.CreateDeposit.prototype.getRecipient = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.CreateDeposit} returns this
 */
proto.iotextypes.CreateDeposit.prototype.setRecipient = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.SettleDeposit.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.SettleDeposit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.SettleDeposit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.SettleDeposit.toObject = function(includeInstance, msg) {
  var f, obj = {
    amount: jspb.Message.getFieldWithDefault(msg, 1, ""),
    recipient: jspb.Message.getFieldWithDefault(msg, 2, ""),
    index: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.SettleDeposit}
 */
proto.iotextypes.SettleDeposit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.SettleDeposit;
  return proto.iotextypes.SettleDeposit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.SettleDeposit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.SettleDeposit}
 */
proto.iotextypes.SettleDeposit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setRecipient(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.SettleDeposit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.SettleDeposit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.SettleDeposit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.SettleDeposit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getRecipient();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getIndex();
  if (f !== 0) {
    writer.writeUint64(
      3,
      f
    );
  }
};


/**
 * optional string amount = 1;
 * @return {string}
 */
proto.iotextypes.SettleDeposit.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.SettleDeposit} returns this
 */
proto.iotextypes.SettleDeposit.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string recipient = 2;
 * @return {string}
 */
proto.iotextypes.SettleDeposit.prototype.getRecipient = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.SettleDeposit} returns this
 */
proto.iotextypes.SettleDeposit.prototype.setRecipient = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional uint64 index = 3;
 * @return {number}
 */
proto.iotextypes.SettleDeposit.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.SettleDeposit} returns this
 */
proto.iotextypes.SettleDeposit.prototype.setIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.CreatePlumChain.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.CreatePlumChain.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.CreatePlumChain} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.CreatePlumChain.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.CreatePlumChain}
 */
proto.iotextypes.CreatePlumChain.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.CreatePlumChain;
  return proto.iotextypes.CreatePlumChain.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.CreatePlumChain} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.CreatePlumChain}
 */
proto.iotextypes.CreatePlumChain.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.CreatePlumChain.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.CreatePlumChain.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.CreatePlumChain} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.CreatePlumChain.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.TerminatePlumChain.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.TerminatePlumChain.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.TerminatePlumChain} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.TerminatePlumChain.toObject = function(includeInstance, msg) {
  var f, obj = {
    subchainaddress: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.TerminatePlumChain}
 */
proto.iotextypes.TerminatePlumChain.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.TerminatePlumChain;
  return proto.iotextypes.TerminatePlumChain.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.TerminatePlumChain} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.TerminatePlumChain}
 */
proto.iotextypes.TerminatePlumChain.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSubchainaddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.TerminatePlumChain.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.TerminatePlumChain.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.TerminatePlumChain} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.TerminatePlumChain.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSubchainaddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string subChainAddress = 1;
 * @return {string}
 */
proto.iotextypes.TerminatePlumChain.prototype.getSubchainaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.TerminatePlumChain} returns this
 */
proto.iotextypes.TerminatePlumChain.prototype.setSubchainaddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.PlumPutBlock.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.PlumPutBlock.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.PlumPutBlock} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumPutBlock.toObject = function(includeInstance, msg) {
  var f, obj = {
    subchainaddress: jspb.Message.getFieldWithDefault(msg, 1, ""),
    height: jspb.Message.getFieldWithDefault(msg, 2, 0),
    rootsMap: (f = msg.getRootsMap()) ? f.toObject(includeInstance, undefined) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.PlumPutBlock}
 */
proto.iotextypes.PlumPutBlock.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.PlumPutBlock;
  return proto.iotextypes.PlumPutBlock.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.PlumPutBlock} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.PlumPutBlock}
 */
proto.iotextypes.PlumPutBlock.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSubchainaddress(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setHeight(value);
      break;
    case 3:
      var value = msg.getRootsMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readBytes, null, "", "");
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumPutBlock.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.PlumPutBlock.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.PlumPutBlock} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumPutBlock.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSubchainaddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getHeight();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getRootsMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(3, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeBytes);
  }
};


/**
 * optional string subChainAddress = 1;
 * @return {string}
 */
proto.iotextypes.PlumPutBlock.prototype.getSubchainaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.PlumPutBlock} returns this
 */
proto.iotextypes.PlumPutBlock.prototype.setSubchainaddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 height = 2;
 * @return {number}
 */
proto.iotextypes.PlumPutBlock.prototype.getHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.PlumPutBlock} returns this
 */
proto.iotextypes.PlumPutBlock.prototype.setHeight = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * map<string, bytes> roots = 3;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!(string|Uint8Array)>}
 */
proto.iotextypes.PlumPutBlock.prototype.getRootsMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,!(string|Uint8Array)>} */ (
      jspb.Message.getMapField(this, 3, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.iotextypes.PlumPutBlock} returns this
 */
proto.iotextypes.PlumPutBlock.prototype.clearRootsMap = function() {
  this.getRootsMap().clear();
  return this;};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.PlumCreateDeposit.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.PlumCreateDeposit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.PlumCreateDeposit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumCreateDeposit.toObject = function(includeInstance, msg) {
  var f, obj = {
    subchainaddress: jspb.Message.getFieldWithDefault(msg, 1, ""),
    amount: jspb.Message.getFieldWithDefault(msg, 2, ""),
    recipient: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.PlumCreateDeposit}
 */
proto.iotextypes.PlumCreateDeposit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.PlumCreateDeposit;
  return proto.iotextypes.PlumCreateDeposit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.PlumCreateDeposit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.PlumCreateDeposit}
 */
proto.iotextypes.PlumCreateDeposit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSubchainaddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setRecipient(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumCreateDeposit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.PlumCreateDeposit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.PlumCreateDeposit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumCreateDeposit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSubchainaddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getRecipient();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional string subChainAddress = 1;
 * @return {string}
 */
proto.iotextypes.PlumCreateDeposit.prototype.getSubchainaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.PlumCreateDeposit} returns this
 */
proto.iotextypes.PlumCreateDeposit.prototype.setSubchainaddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string amount = 2;
 * @return {string}
 */
proto.iotextypes.PlumCreateDeposit.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.PlumCreateDeposit} returns this
 */
proto.iotextypes.PlumCreateDeposit.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string recipient = 3;
 * @return {string}
 */
proto.iotextypes.PlumCreateDeposit.prototype.getRecipient = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.PlumCreateDeposit} returns this
 */
proto.iotextypes.PlumCreateDeposit.prototype.setRecipient = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.PlumStartExit.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.PlumStartExit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.PlumStartExit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumStartExit.toObject = function(includeInstance, msg) {
  var f, obj = {
    subchainaddress: jspb.Message.getFieldWithDefault(msg, 1, ""),
    previoustransfer: msg.getPrevioustransfer_asB64(),
    previoustransferblockproof: msg.getPrevioustransferblockproof_asB64(),
    previoustransferblockheight: jspb.Message.getFieldWithDefault(msg, 4, 0),
    exittransfer: msg.getExittransfer_asB64(),
    exittransferblockproof: msg.getExittransferblockproof_asB64(),
    exittransferblockheight: jspb.Message.getFieldWithDefault(msg, 7, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.PlumStartExit}
 */
proto.iotextypes.PlumStartExit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.PlumStartExit;
  return proto.iotextypes.PlumStartExit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.PlumStartExit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.PlumStartExit}
 */
proto.iotextypes.PlumStartExit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSubchainaddress(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrevioustransfer(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrevioustransferblockproof(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setPrevioustransferblockheight(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setExittransfer(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setExittransferblockproof(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setExittransferblockheight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumStartExit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.PlumStartExit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.PlumStartExit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumStartExit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSubchainaddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPrevioustransfer_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getPrevioustransferblockproof_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getPrevioustransferblockheight();
  if (f !== 0) {
    writer.writeUint64(
      4,
      f
    );
  }
  f = message.getExittransfer_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = message.getExittransferblockproof_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      6,
      f
    );
  }
  f = message.getExittransferblockheight();
  if (f !== 0) {
    writer.writeUint64(
      7,
      f
    );
  }
};


/**
 * optional string subChainAddress = 1;
 * @return {string}
 */
proto.iotextypes.PlumStartExit.prototype.getSubchainaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.PlumStartExit} returns this
 */
proto.iotextypes.PlumStartExit.prototype.setSubchainaddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional bytes previousTransfer = 2;
 * @return {string}
 */
proto.iotextypes.PlumStartExit.prototype.getPrevioustransfer = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes previousTransfer = 2;
 * This is a type-conversion wrapper around `getPrevioustransfer()`
 * @return {string}
 */
proto.iotextypes.PlumStartExit.prototype.getPrevioustransfer_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrevioustransfer()));
};


/**
 * optional bytes previousTransfer = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrevioustransfer()`
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumStartExit.prototype.getPrevioustransfer_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrevioustransfer()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.PlumStartExit} returns this
 */
proto.iotextypes.PlumStartExit.prototype.setPrevioustransfer = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional bytes previousTransferBlockProof = 3;
 * @return {string}
 */
proto.iotextypes.PlumStartExit.prototype.getPrevioustransferblockproof = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes previousTransferBlockProof = 3;
 * This is a type-conversion wrapper around `getPrevioustransferblockproof()`
 * @return {string}
 */
proto.iotextypes.PlumStartExit.prototype.getPrevioustransferblockproof_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrevioustransferblockproof()));
};


/**
 * optional bytes previousTransferBlockProof = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrevioustransferblockproof()`
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumStartExit.prototype.getPrevioustransferblockproof_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrevioustransferblockproof()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.PlumStartExit} returns this
 */
proto.iotextypes.PlumStartExit.prototype.setPrevioustransferblockproof = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional uint64 previousTransferBlockHeight = 4;
 * @return {number}
 */
proto.iotextypes.PlumStartExit.prototype.getPrevioustransferblockheight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.PlumStartExit} returns this
 */
proto.iotextypes.PlumStartExit.prototype.setPrevioustransferblockheight = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional bytes exitTransfer = 5;
 * @return {string}
 */
proto.iotextypes.PlumStartExit.prototype.getExittransfer = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes exitTransfer = 5;
 * This is a type-conversion wrapper around `getExittransfer()`
 * @return {string}
 */
proto.iotextypes.PlumStartExit.prototype.getExittransfer_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getExittransfer()));
};


/**
 * optional bytes exitTransfer = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getExittransfer()`
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumStartExit.prototype.getExittransfer_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getExittransfer()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.PlumStartExit} returns this
 */
proto.iotextypes.PlumStartExit.prototype.setExittransfer = function(value) {
  return jspb.Message.setProto3BytesField(this, 5, value);
};


/**
 * optional bytes exitTransferBlockProof = 6;
 * @return {string}
 */
proto.iotextypes.PlumStartExit.prototype.getExittransferblockproof = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * optional bytes exitTransferBlockProof = 6;
 * This is a type-conversion wrapper around `getExittransferblockproof()`
 * @return {string}
 */
proto.iotextypes.PlumStartExit.prototype.getExittransferblockproof_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getExittransferblockproof()));
};


/**
 * optional bytes exitTransferBlockProof = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getExittransferblockproof()`
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumStartExit.prototype.getExittransferblockproof_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getExittransferblockproof()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.PlumStartExit} returns this
 */
proto.iotextypes.PlumStartExit.prototype.setExittransferblockproof = function(value) {
  return jspb.Message.setProto3BytesField(this, 6, value);
};


/**
 * optional uint64 exitTransferBlockHeight = 7;
 * @return {number}
 */
proto.iotextypes.PlumStartExit.prototype.getExittransferblockheight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.PlumStartExit} returns this
 */
proto.iotextypes.PlumStartExit.prototype.setExittransferblockheight = function(value) {
  return jspb.Message.setProto3IntField(this, 7, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.PlumChallengeExit.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.PlumChallengeExit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.PlumChallengeExit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumChallengeExit.toObject = function(includeInstance, msg) {
  var f, obj = {
    subchainaddress: jspb.Message.getFieldWithDefault(msg, 1, ""),
    coinid: jspb.Message.getFieldWithDefault(msg, 2, 0),
    challengetransfer: msg.getChallengetransfer_asB64(),
    challengetransferblockproof: msg.getChallengetransferblockproof_asB64(),
    challengetransferblockheight: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.PlumChallengeExit}
 */
proto.iotextypes.PlumChallengeExit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.PlumChallengeExit;
  return proto.iotextypes.PlumChallengeExit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.PlumChallengeExit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.PlumChallengeExit}
 */
proto.iotextypes.PlumChallengeExit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSubchainaddress(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setCoinid(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setChallengetransfer(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setChallengetransferblockproof(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setChallengetransferblockheight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumChallengeExit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.PlumChallengeExit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.PlumChallengeExit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumChallengeExit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSubchainaddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getCoinid();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getChallengetransfer_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getChallengetransferblockproof_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getChallengetransferblockheight();
  if (f !== 0) {
    writer.writeUint64(
      5,
      f
    );
  }
};


/**
 * optional string subChainAddress = 1;
 * @return {string}
 */
proto.iotextypes.PlumChallengeExit.prototype.getSubchainaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.PlumChallengeExit} returns this
 */
proto.iotextypes.PlumChallengeExit.prototype.setSubchainaddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 coinID = 2;
 * @return {number}
 */
proto.iotextypes.PlumChallengeExit.prototype.getCoinid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.PlumChallengeExit} returns this
 */
proto.iotextypes.PlumChallengeExit.prototype.setCoinid = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bytes challengeTransfer = 3;
 * @return {string}
 */
proto.iotextypes.PlumChallengeExit.prototype.getChallengetransfer = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes challengeTransfer = 3;
 * This is a type-conversion wrapper around `getChallengetransfer()`
 * @return {string}
 */
proto.iotextypes.PlumChallengeExit.prototype.getChallengetransfer_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getChallengetransfer()));
};


/**
 * optional bytes challengeTransfer = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getChallengetransfer()`
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumChallengeExit.prototype.getChallengetransfer_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getChallengetransfer()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.PlumChallengeExit} returns this
 */
proto.iotextypes.PlumChallengeExit.prototype.setChallengetransfer = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional bytes challengeTransferBlockProof = 4;
 * @return {string}
 */
proto.iotextypes.PlumChallengeExit.prototype.getChallengetransferblockproof = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes challengeTransferBlockProof = 4;
 * This is a type-conversion wrapper around `getChallengetransferblockproof()`
 * @return {string}
 */
proto.iotextypes.PlumChallengeExit.prototype.getChallengetransferblockproof_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getChallengetransferblockproof()));
};


/**
 * optional bytes challengeTransferBlockProof = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getChallengetransferblockproof()`
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumChallengeExit.prototype.getChallengetransferblockproof_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getChallengetransferblockproof()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.PlumChallengeExit} returns this
 */
proto.iotextypes.PlumChallengeExit.prototype.setChallengetransferblockproof = function(value) {
  return jspb.Message.setProto3BytesField(this, 4, value);
};


/**
 * optional uint64 challengeTransferBlockHeight = 5;
 * @return {number}
 */
proto.iotextypes.PlumChallengeExit.prototype.getChallengetransferblockheight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.PlumChallengeExit} returns this
 */
proto.iotextypes.PlumChallengeExit.prototype.setChallengetransferblockheight = function(value) {
  return jspb.Message.setProto3IntField(this, 5, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.PlumResponseChallengeExit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.PlumResponseChallengeExit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumResponseChallengeExit.toObject = function(includeInstance, msg) {
  var f, obj = {
    subchainaddress: jspb.Message.getFieldWithDefault(msg, 1, ""),
    coinid: jspb.Message.getFieldWithDefault(msg, 2, 0),
    challengetransfer: msg.getChallengetransfer_asB64(),
    responsetransfer: msg.getResponsetransfer_asB64(),
    responsetransferblockproof: msg.getResponsetransferblockproof_asB64(),
    previoustransferblockheight: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.PlumResponseChallengeExit}
 */
proto.iotextypes.PlumResponseChallengeExit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.PlumResponseChallengeExit;
  return proto.iotextypes.PlumResponseChallengeExit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.PlumResponseChallengeExit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.PlumResponseChallengeExit}
 */
proto.iotextypes.PlumResponseChallengeExit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSubchainaddress(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setCoinid(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setChallengetransfer(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setResponsetransfer(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setResponsetransferblockproof(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setPrevioustransferblockheight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.PlumResponseChallengeExit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.PlumResponseChallengeExit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumResponseChallengeExit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSubchainaddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getCoinid();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getChallengetransfer_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getResponsetransfer_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getResponsetransferblockproof_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = message.getPrevioustransferblockheight();
  if (f !== 0) {
    writer.writeUint64(
      6,
      f
    );
  }
};


/**
 * optional string subChainAddress = 1;
 * @return {string}
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.getSubchainaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.PlumResponseChallengeExit} returns this
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.setSubchainaddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 coinID = 2;
 * @return {number}
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.getCoinid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.PlumResponseChallengeExit} returns this
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.setCoinid = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bytes challengeTransfer = 3;
 * @return {string}
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.getChallengetransfer = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes challengeTransfer = 3;
 * This is a type-conversion wrapper around `getChallengetransfer()`
 * @return {string}
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.getChallengetransfer_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getChallengetransfer()));
};


/**
 * optional bytes challengeTransfer = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getChallengetransfer()`
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.getChallengetransfer_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getChallengetransfer()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.PlumResponseChallengeExit} returns this
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.setChallengetransfer = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional bytes responseTransfer = 4;
 * @return {string}
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.getResponsetransfer = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes responseTransfer = 4;
 * This is a type-conversion wrapper around `getResponsetransfer()`
 * @return {string}
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.getResponsetransfer_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getResponsetransfer()));
};


/**
 * optional bytes responseTransfer = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getResponsetransfer()`
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.getResponsetransfer_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getResponsetransfer()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.PlumResponseChallengeExit} returns this
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.setResponsetransfer = function(value) {
  return jspb.Message.setProto3BytesField(this, 4, value);
};


/**
 * optional bytes responseTransferBlockProof = 5;
 * @return {string}
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.getResponsetransferblockproof = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes responseTransferBlockProof = 5;
 * This is a type-conversion wrapper around `getResponsetransferblockproof()`
 * @return {string}
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.getResponsetransferblockproof_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getResponsetransferblockproof()));
};


/**
 * optional bytes responseTransferBlockProof = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getResponsetransferblockproof()`
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.getResponsetransferblockproof_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getResponsetransferblockproof()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.PlumResponseChallengeExit} returns this
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.setResponsetransferblockproof = function(value) {
  return jspb.Message.setProto3BytesField(this, 5, value);
};


/**
 * optional uint64 previousTransferBlockHeight = 6;
 * @return {number}
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.getPrevioustransferblockheight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.PlumResponseChallengeExit} returns this
 */
proto.iotextypes.PlumResponseChallengeExit.prototype.setPrevioustransferblockheight = function(value) {
  return jspb.Message.setProto3IntField(this, 6, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.PlumFinalizeExit.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.PlumFinalizeExit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.PlumFinalizeExit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumFinalizeExit.toObject = function(includeInstance, msg) {
  var f, obj = {
    subchainaddress: jspb.Message.getFieldWithDefault(msg, 1, ""),
    coinid: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.PlumFinalizeExit}
 */
proto.iotextypes.PlumFinalizeExit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.PlumFinalizeExit;
  return proto.iotextypes.PlumFinalizeExit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.PlumFinalizeExit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.PlumFinalizeExit}
 */
proto.iotextypes.PlumFinalizeExit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSubchainaddress(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setCoinid(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumFinalizeExit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.PlumFinalizeExit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.PlumFinalizeExit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumFinalizeExit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSubchainaddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getCoinid();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
};


/**
 * optional string subChainAddress = 1;
 * @return {string}
 */
proto.iotextypes.PlumFinalizeExit.prototype.getSubchainaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.PlumFinalizeExit} returns this
 */
proto.iotextypes.PlumFinalizeExit.prototype.setSubchainaddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional uint64 coinID = 2;
 * @return {number}
 */
proto.iotextypes.PlumFinalizeExit.prototype.getCoinid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.PlumFinalizeExit} returns this
 */
proto.iotextypes.PlumFinalizeExit.prototype.setCoinid = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.PlumSettleDeposit.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.PlumSettleDeposit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.PlumSettleDeposit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumSettleDeposit.toObject = function(includeInstance, msg) {
  var f, obj = {
    coinid: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.PlumSettleDeposit}
 */
proto.iotextypes.PlumSettleDeposit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.PlumSettleDeposit;
  return proto.iotextypes.PlumSettleDeposit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.PlumSettleDeposit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.PlumSettleDeposit}
 */
proto.iotextypes.PlumSettleDeposit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setCoinid(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumSettleDeposit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.PlumSettleDeposit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.PlumSettleDeposit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumSettleDeposit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCoinid();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
};


/**
 * optional uint64 coinID = 1;
 * @return {number}
 */
proto.iotextypes.PlumSettleDeposit.prototype.getCoinid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.PlumSettleDeposit} returns this
 */
proto.iotextypes.PlumSettleDeposit.prototype.setCoinid = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.PlumTransfer.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.PlumTransfer.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.PlumTransfer} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumTransfer.toObject = function(includeInstance, msg) {
  var f, obj = {
    coinid: jspb.Message.getFieldWithDefault(msg, 1, 0),
    denomination: msg.getDenomination_asB64(),
    owner: jspb.Message.getFieldWithDefault(msg, 3, ""),
    recipient: jspb.Message.getFieldWithDefault(msg, 4, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.PlumTransfer}
 */
proto.iotextypes.PlumTransfer.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.PlumTransfer;
  return proto.iotextypes.PlumTransfer.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.PlumTransfer} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.PlumTransfer}
 */
proto.iotextypes.PlumTransfer.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setCoinid(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setDenomination(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setOwner(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setRecipient(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumTransfer.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.PlumTransfer.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.PlumTransfer} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.PlumTransfer.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCoinid();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getDenomination_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getOwner();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getRecipient();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
};


/**
 * optional uint64 coinID = 1;
 * @return {number}
 */
proto.iotextypes.PlumTransfer.prototype.getCoinid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.PlumTransfer} returns this
 */
proto.iotextypes.PlumTransfer.prototype.setCoinid = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional bytes denomination = 2;
 * @return {string}
 */
proto.iotextypes.PlumTransfer.prototype.getDenomination = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes denomination = 2;
 * This is a type-conversion wrapper around `getDenomination()`
 * @return {string}
 */
proto.iotextypes.PlumTransfer.prototype.getDenomination_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getDenomination()));
};


/**
 * optional bytes denomination = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getDenomination()`
 * @return {!Uint8Array}
 */
proto.iotextypes.PlumTransfer.prototype.getDenomination_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getDenomination()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.PlumTransfer} returns this
 */
proto.iotextypes.PlumTransfer.prototype.setDenomination = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional string owner = 3;
 * @return {string}
 */
proto.iotextypes.PlumTransfer.prototype.getOwner = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.PlumTransfer} returns this
 */
proto.iotextypes.PlumTransfer.prototype.setOwner = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string recipient = 4;
 * @return {string}
 */
proto.iotextypes.PlumTransfer.prototype.getRecipient = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.PlumTransfer} returns this
 */
proto.iotextypes.PlumTransfer.prototype.setRecipient = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.iotextypes.ActionCore.oneofGroups_ = [[10,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,30,31,32,40,41,42,43,44,45,46,47,48,50]];

/**
 * @enum {number}
 */
proto.iotextypes.ActionCore.ActionCase = {
  ACTION_NOT_SET: 0,
  TRANSFER: 10,
  EXECUTION: 12,
  STARTSUBCHAIN: 13,
  STOPSUBCHAIN: 14,
  PUTBLOCK: 15,
  CREATEDEPOSIT: 16,
  SETTLEDEPOSIT: 17,
  CREATEPLUMCHAIN: 18,
  TERMINATEPLUMCHAIN: 19,
  PLUMPUTBLOCK: 20,
  PLUMCREATEDEPOSIT: 21,
  PLUMSTARTEXIT: 22,
  PLUMCHALLENGEEXIT: 23,
  PLUMRESPONSECHALLENGEEXIT: 24,
  PLUMFINALIZEEXIT: 25,
  PLUMSETTLEDEPOSIT: 26,
  PLUMTRANSFER: 27,
  DEPOSITTOREWARDINGFUND: 30,
  CLAIMFROMREWARDINGFUND: 31,
  GRANTREWARD: 32,
  STAKECREATE: 40,
  STAKEUNSTAKE: 41,
  STAKEWITHDRAW: 42,
  STAKEADDDEPOSIT: 43,
  STAKERESTAKE: 44,
  STAKECHANGECANDIDATE: 45,
  STAKETRANSFEROWNERSHIP: 46,
  CANDIDATEREGISTER: 47,
  CANDIDATEUPDATE: 48,
  PUTPOLLRESULT: 50
};

/**
 * @return {proto.iotextypes.ActionCore.ActionCase}
 */
proto.iotextypes.ActionCore.prototype.getActionCase = function() {
  return /** @type {proto.iotextypes.ActionCore.ActionCase} */(jspb.Message.computeOneofCase(this, proto.iotextypes.ActionCore.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.ActionCore.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.ActionCore.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.ActionCore} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.ActionCore.toObject = function(includeInstance, msg) {
  var f, obj = {
    version: jspb.Message.getFieldWithDefault(msg, 1, 0),
    nonce: jspb.Message.getFieldWithDefault(msg, 2, 0),
    gaslimit: jspb.Message.getFieldWithDefault(msg, 3, 0),
    gasprice: jspb.Message.getFieldWithDefault(msg, 4, ""),
    chainid: jspb.Message.getFieldWithDefault(msg, 5, 0),
    transfer: (f = msg.getTransfer()) && proto.iotextypes.Transfer.toObject(includeInstance, f),
    execution: (f = msg.getExecution()) && proto.iotextypes.Execution.toObject(includeInstance, f),
    startsubchain: (f = msg.getStartsubchain()) && proto.iotextypes.StartSubChain.toObject(includeInstance, f),
    stopsubchain: (f = msg.getStopsubchain()) && proto.iotextypes.StopSubChain.toObject(includeInstance, f),
    putblock: (f = msg.getPutblock()) && proto.iotextypes.PutBlock.toObject(includeInstance, f),
    createdeposit: (f = msg.getCreatedeposit()) && proto.iotextypes.CreateDeposit.toObject(includeInstance, f),
    settledeposit: (f = msg.getSettledeposit()) && proto.iotextypes.SettleDeposit.toObject(includeInstance, f),
    createplumchain: (f = msg.getCreateplumchain()) && proto.iotextypes.CreatePlumChain.toObject(includeInstance, f),
    terminateplumchain: (f = msg.getTerminateplumchain()) && proto.iotextypes.TerminatePlumChain.toObject(includeInstance, f),
    plumputblock: (f = msg.getPlumputblock()) && proto.iotextypes.PlumPutBlock.toObject(includeInstance, f),
    plumcreatedeposit: (f = msg.getPlumcreatedeposit()) && proto.iotextypes.PlumCreateDeposit.toObject(includeInstance, f),
    plumstartexit: (f = msg.getPlumstartexit()) && proto.iotextypes.PlumStartExit.toObject(includeInstance, f),
    plumchallengeexit: (f = msg.getPlumchallengeexit()) && proto.iotextypes.PlumChallengeExit.toObject(includeInstance, f),
    plumresponsechallengeexit: (f = msg.getPlumresponsechallengeexit()) && proto.iotextypes.PlumResponseChallengeExit.toObject(includeInstance, f),
    plumfinalizeexit: (f = msg.getPlumfinalizeexit()) && proto.iotextypes.PlumFinalizeExit.toObject(includeInstance, f),
    plumsettledeposit: (f = msg.getPlumsettledeposit()) && proto.iotextypes.PlumSettleDeposit.toObject(includeInstance, f),
    plumtransfer: (f = msg.getPlumtransfer()) && proto.iotextypes.PlumTransfer.toObject(includeInstance, f),
    deposittorewardingfund: (f = msg.getDeposittorewardingfund()) && proto.iotextypes.DepositToRewardingFund.toObject(includeInstance, f),
    claimfromrewardingfund: (f = msg.getClaimfromrewardingfund()) && proto.iotextypes.ClaimFromRewardingFund.toObject(includeInstance, f),
    grantreward: (f = msg.getGrantreward()) && proto.iotextypes.GrantReward.toObject(includeInstance, f),
    stakecreate: (f = msg.getStakecreate()) && proto.iotextypes.StakeCreate.toObject(includeInstance, f),
    stakeunstake: (f = msg.getStakeunstake()) && proto.iotextypes.StakeReclaim.toObject(includeInstance, f),
    stakewithdraw: (f = msg.getStakewithdraw()) && proto.iotextypes.StakeReclaim.toObject(includeInstance, f),
    stakeadddeposit: (f = msg.getStakeadddeposit()) && proto.iotextypes.StakeAddDeposit.toObject(includeInstance, f),
    stakerestake: (f = msg.getStakerestake()) && proto.iotextypes.StakeRestake.toObject(includeInstance, f),
    stakechangecandidate: (f = msg.getStakechangecandidate()) && proto.iotextypes.StakeChangeCandidate.toObject(includeInstance, f),
    staketransferownership: (f = msg.getStaketransferownership()) && proto.iotextypes.StakeTransferOwnership.toObject(includeInstance, f),
    candidateregister: (f = msg.getCandidateregister()) && proto.iotextypes.CandidateRegister.toObject(includeInstance, f),
    candidateupdate: (f = msg.getCandidateupdate()) && proto.iotextypes.CandidateBasicInfo.toObject(includeInstance, f),
    putpollresult: (f = msg.getPutpollresult()) && proto.iotextypes.PutPollResult.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.ActionCore}
 */
proto.iotextypes.ActionCore.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.ActionCore;
  return proto.iotextypes.ActionCore.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.ActionCore} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.ActionCore}
 */
proto.iotextypes.ActionCore.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVersion(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNonce(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setGaslimit(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setGasprice(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setChainid(value);
      break;
    case 10:
      var value = new proto.iotextypes.Transfer;
      reader.readMessage(value,proto.iotextypes.Transfer.deserializeBinaryFromReader);
      msg.setTransfer(value);
      break;
    case 12:
      var value = new proto.iotextypes.Execution;
      reader.readMessage(value,proto.iotextypes.Execution.deserializeBinaryFromReader);
      msg.setExecution(value);
      break;
    case 13:
      var value = new proto.iotextypes.StartSubChain;
      reader.readMessage(value,proto.iotextypes.StartSubChain.deserializeBinaryFromReader);
      msg.setStartsubchain(value);
      break;
    case 14:
      var value = new proto.iotextypes.StopSubChain;
      reader.readMessage(value,proto.iotextypes.StopSubChain.deserializeBinaryFromReader);
      msg.setStopsubchain(value);
      break;
    case 15:
      var value = new proto.iotextypes.PutBlock;
      reader.readMessage(value,proto.iotextypes.PutBlock.deserializeBinaryFromReader);
      msg.setPutblock(value);
      break;
    case 16:
      var value = new proto.iotextypes.CreateDeposit;
      reader.readMessage(value,proto.iotextypes.CreateDeposit.deserializeBinaryFromReader);
      msg.setCreatedeposit(value);
      break;
    case 17:
      var value = new proto.iotextypes.SettleDeposit;
      reader.readMessage(value,proto.iotextypes.SettleDeposit.deserializeBinaryFromReader);
      msg.setSettledeposit(value);
      break;
    case 18:
      var value = new proto.iotextypes.CreatePlumChain;
      reader.readMessage(value,proto.iotextypes.CreatePlumChain.deserializeBinaryFromReader);
      msg.setCreateplumchain(value);
      break;
    case 19:
      var value = new proto.iotextypes.TerminatePlumChain;
      reader.readMessage(value,proto.iotextypes.TerminatePlumChain.deserializeBinaryFromReader);
      msg.setTerminateplumchain(value);
      break;
    case 20:
      var value = new proto.iotextypes.PlumPutBlock;
      reader.readMessage(value,proto.iotextypes.PlumPutBlock.deserializeBinaryFromReader);
      msg.setPlumputblock(value);
      break;
    case 21:
      var value = new proto.iotextypes.PlumCreateDeposit;
      reader.readMessage(value,proto.iotextypes.PlumCreateDeposit.deserializeBinaryFromReader);
      msg.setPlumcreatedeposit(value);
      break;
    case 22:
      var value = new proto.iotextypes.PlumStartExit;
      reader.readMessage(value,proto.iotextypes.PlumStartExit.deserializeBinaryFromReader);
      msg.setPlumstartexit(value);
      break;
    case 23:
      var value = new proto.iotextypes.PlumChallengeExit;
      reader.readMessage(value,proto.iotextypes.PlumChallengeExit.deserializeBinaryFromReader);
      msg.setPlumchallengeexit(value);
      break;
    case 24:
      var value = new proto.iotextypes.PlumResponseChallengeExit;
      reader.readMessage(value,proto.iotextypes.PlumResponseChallengeExit.deserializeBinaryFromReader);
      msg.setPlumresponsechallengeexit(value);
      break;
    case 25:
      var value = new proto.iotextypes.PlumFinalizeExit;
      reader.readMessage(value,proto.iotextypes.PlumFinalizeExit.deserializeBinaryFromReader);
      msg.setPlumfinalizeexit(value);
      break;
    case 26:
      var value = new proto.iotextypes.PlumSettleDeposit;
      reader.readMessage(value,proto.iotextypes.PlumSettleDeposit.deserializeBinaryFromReader);
      msg.setPlumsettledeposit(value);
      break;
    case 27:
      var value = new proto.iotextypes.PlumTransfer;
      reader.readMessage(value,proto.iotextypes.PlumTransfer.deserializeBinaryFromReader);
      msg.setPlumtransfer(value);
      break;
    case 30:
      var value = new proto.iotextypes.DepositToRewardingFund;
      reader.readMessage(value,proto.iotextypes.DepositToRewardingFund.deserializeBinaryFromReader);
      msg.setDeposittorewardingfund(value);
      break;
    case 31:
      var value = new proto.iotextypes.ClaimFromRewardingFund;
      reader.readMessage(value,proto.iotextypes.ClaimFromRewardingFund.deserializeBinaryFromReader);
      msg.setClaimfromrewardingfund(value);
      break;
    case 32:
      var value = new proto.iotextypes.GrantReward;
      reader.readMessage(value,proto.iotextypes.GrantReward.deserializeBinaryFromReader);
      msg.setGrantreward(value);
      break;
    case 40:
      var value = new proto.iotextypes.StakeCreate;
      reader.readMessage(value,proto.iotextypes.StakeCreate.deserializeBinaryFromReader);
      msg.setStakecreate(value);
      break;
    case 41:
      var value = new proto.iotextypes.StakeReclaim;
      reader.readMessage(value,proto.iotextypes.StakeReclaim.deserializeBinaryFromReader);
      msg.setStakeunstake(value);
      break;
    case 42:
      var value = new proto.iotextypes.StakeReclaim;
      reader.readMessage(value,proto.iotextypes.StakeReclaim.deserializeBinaryFromReader);
      msg.setStakewithdraw(value);
      break;
    case 43:
      var value = new proto.iotextypes.StakeAddDeposit;
      reader.readMessage(value,proto.iotextypes.StakeAddDeposit.deserializeBinaryFromReader);
      msg.setStakeadddeposit(value);
      break;
    case 44:
      var value = new proto.iotextypes.StakeRestake;
      reader.readMessage(value,proto.iotextypes.StakeRestake.deserializeBinaryFromReader);
      msg.setStakerestake(value);
      break;
    case 45:
      var value = new proto.iotextypes.StakeChangeCandidate;
      reader.readMessage(value,proto.iotextypes.StakeChangeCandidate.deserializeBinaryFromReader);
      msg.setStakechangecandidate(value);
      break;
    case 46:
      var value = new proto.iotextypes.StakeTransferOwnership;
      reader.readMessage(value,proto.iotextypes.StakeTransferOwnership.deserializeBinaryFromReader);
      msg.setStaketransferownership(value);
      break;
    case 47:
      var value = new proto.iotextypes.CandidateRegister;
      reader.readMessage(value,proto.iotextypes.CandidateRegister.deserializeBinaryFromReader);
      msg.setCandidateregister(value);
      break;
    case 48:
      var value = new proto.iotextypes.CandidateBasicInfo;
      reader.readMessage(value,proto.iotextypes.CandidateBasicInfo.deserializeBinaryFromReader);
      msg.setCandidateupdate(value);
      break;
    case 50:
      var value = new proto.iotextypes.PutPollResult;
      reader.readMessage(value,proto.iotextypes.PutPollResult.deserializeBinaryFromReader);
      msg.setPutpollresult(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.ActionCore.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.ActionCore.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.ActionCore} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.ActionCore.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVersion();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getNonce();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getGaslimit();
  if (f !== 0) {
    writer.writeUint64(
      3,
      f
    );
  }
  f = message.getGasprice();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getChainid();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = message.getTransfer();
  if (f != null) {
    writer.writeMessage(
      10,
      f,
      proto.iotextypes.Transfer.serializeBinaryToWriter
    );
  }
  f = message.getExecution();
  if (f != null) {
    writer.writeMessage(
      12,
      f,
      proto.iotextypes.Execution.serializeBinaryToWriter
    );
  }
  f = message.getStartsubchain();
  if (f != null) {
    writer.writeMessage(
      13,
      f,
      proto.iotextypes.StartSubChain.serializeBinaryToWriter
    );
  }
  f = message.getStopsubchain();
  if (f != null) {
    writer.writeMessage(
      14,
      f,
      proto.iotextypes.StopSubChain.serializeBinaryToWriter
    );
  }
  f = message.getPutblock();
  if (f != null) {
    writer.writeMessage(
      15,
      f,
      proto.iotextypes.PutBlock.serializeBinaryToWriter
    );
  }
  f = message.getCreatedeposit();
  if (f != null) {
    writer.writeMessage(
      16,
      f,
      proto.iotextypes.CreateDeposit.serializeBinaryToWriter
    );
  }
  f = message.getSettledeposit();
  if (f != null) {
    writer.writeMessage(
      17,
      f,
      proto.iotextypes.SettleDeposit.serializeBinaryToWriter
    );
  }
  f = message.getCreateplumchain();
  if (f != null) {
    writer.writeMessage(
      18,
      f,
      proto.iotextypes.CreatePlumChain.serializeBinaryToWriter
    );
  }
  f = message.getTerminateplumchain();
  if (f != null) {
    writer.writeMessage(
      19,
      f,
      proto.iotextypes.TerminatePlumChain.serializeBinaryToWriter
    );
  }
  f = message.getPlumputblock();
  if (f != null) {
    writer.writeMessage(
      20,
      f,
      proto.iotextypes.PlumPutBlock.serializeBinaryToWriter
    );
  }
  f = message.getPlumcreatedeposit();
  if (f != null) {
    writer.writeMessage(
      21,
      f,
      proto.iotextypes.PlumCreateDeposit.serializeBinaryToWriter
    );
  }
  f = message.getPlumstartexit();
  if (f != null) {
    writer.writeMessage(
      22,
      f,
      proto.iotextypes.PlumStartExit.serializeBinaryToWriter
    );
  }
  f = message.getPlumchallengeexit();
  if (f != null) {
    writer.writeMessage(
      23,
      f,
      proto.iotextypes.PlumChallengeExit.serializeBinaryToWriter
    );
  }
  f = message.getPlumresponsechallengeexit();
  if (f != null) {
    writer.writeMessage(
      24,
      f,
      proto.iotextypes.PlumResponseChallengeExit.serializeBinaryToWriter
    );
  }
  f = message.getPlumfinalizeexit();
  if (f != null) {
    writer.writeMessage(
      25,
      f,
      proto.iotextypes.PlumFinalizeExit.serializeBinaryToWriter
    );
  }
  f = message.getPlumsettledeposit();
  if (f != null) {
    writer.writeMessage(
      26,
      f,
      proto.iotextypes.PlumSettleDeposit.serializeBinaryToWriter
    );
  }
  f = message.getPlumtransfer();
  if (f != null) {
    writer.writeMessage(
      27,
      f,
      proto.iotextypes.PlumTransfer.serializeBinaryToWriter
    );
  }
  f = message.getDeposittorewardingfund();
  if (f != null) {
    writer.writeMessage(
      30,
      f,
      proto.iotextypes.DepositToRewardingFund.serializeBinaryToWriter
    );
  }
  f = message.getClaimfromrewardingfund();
  if (f != null) {
    writer.writeMessage(
      31,
      f,
      proto.iotextypes.ClaimFromRewardingFund.serializeBinaryToWriter
    );
  }
  f = message.getGrantreward();
  if (f != null) {
    writer.writeMessage(
      32,
      f,
      proto.iotextypes.GrantReward.serializeBinaryToWriter
    );
  }
  f = message.getStakecreate();
  if (f != null) {
    writer.writeMessage(
      40,
      f,
      proto.iotextypes.StakeCreate.serializeBinaryToWriter
    );
  }
  f = message.getStakeunstake();
  if (f != null) {
    writer.writeMessage(
      41,
      f,
      proto.iotextypes.StakeReclaim.serializeBinaryToWriter
    );
  }
  f = message.getStakewithdraw();
  if (f != null) {
    writer.writeMessage(
      42,
      f,
      proto.iotextypes.StakeReclaim.serializeBinaryToWriter
    );
  }
  f = message.getStakeadddeposit();
  if (f != null) {
    writer.writeMessage(
      43,
      f,
      proto.iotextypes.StakeAddDeposit.serializeBinaryToWriter
    );
  }
  f = message.getStakerestake();
  if (f != null) {
    writer.writeMessage(
      44,
      f,
      proto.iotextypes.StakeRestake.serializeBinaryToWriter
    );
  }
  f = message.getStakechangecandidate();
  if (f != null) {
    writer.writeMessage(
      45,
      f,
      proto.iotextypes.StakeChangeCandidate.serializeBinaryToWriter
    );
  }
  f = message.getStaketransferownership();
  if (f != null) {
    writer.writeMessage(
      46,
      f,
      proto.iotextypes.StakeTransferOwnership.serializeBinaryToWriter
    );
  }
  f = message.getCandidateregister();
  if (f != null) {
    writer.writeMessage(
      47,
      f,
      proto.iotextypes.CandidateRegister.serializeBinaryToWriter
    );
  }
  f = message.getCandidateupdate();
  if (f != null) {
    writer.writeMessage(
      48,
      f,
      proto.iotextypes.CandidateBasicInfo.serializeBinaryToWriter
    );
  }
  f = message.getPutpollresult();
  if (f != null) {
    writer.writeMessage(
      50,
      f,
      proto.iotextypes.PutPollResult.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint32 version = 1;
 * @return {number}
 */
proto.iotextypes.ActionCore.prototype.getVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.setVersion = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 nonce = 2;
 * @return {number}
 */
proto.iotextypes.ActionCore.prototype.getNonce = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.setNonce = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional uint64 gasLimit = 3;
 * @return {number}
 */
proto.iotextypes.ActionCore.prototype.getGaslimit = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.setGaslimit = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional string gasPrice = 4;
 * @return {string}
 */
proto.iotextypes.ActionCore.prototype.getGasprice = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.setGasprice = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional uint32 chainID = 5;
 * @return {number}
 */
proto.iotextypes.ActionCore.prototype.getChainid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.setChainid = function(value) {
  return jspb.Message.setProto3IntField(this, 5, value);
};


/**
 * optional Transfer transfer = 10;
 * @return {?proto.iotextypes.Transfer}
 */
proto.iotextypes.ActionCore.prototype.getTransfer = function() {
  return /** @type{?proto.iotextypes.Transfer} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.Transfer, 10));
};


/**
 * @param {?proto.iotextypes.Transfer|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setTransfer = function(value) {
  return jspb.Message.setOneofWrapperField(this, 10, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearTransfer = function() {
  return this.setTransfer(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasTransfer = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional Execution execution = 12;
 * @return {?proto.iotextypes.Execution}
 */
proto.iotextypes.ActionCore.prototype.getExecution = function() {
  return /** @type{?proto.iotextypes.Execution} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.Execution, 12));
};


/**
 * @param {?proto.iotextypes.Execution|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setExecution = function(value) {
  return jspb.Message.setOneofWrapperField(this, 12, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearExecution = function() {
  return this.setExecution(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasExecution = function() {
  return jspb.Message.getField(this, 12) != null;
};


/**
 * optional StartSubChain startSubChain = 13;
 * @return {?proto.iotextypes.StartSubChain}
 */
proto.iotextypes.ActionCore.prototype.getStartsubchain = function() {
  return /** @type{?proto.iotextypes.StartSubChain} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.StartSubChain, 13));
};


/**
 * @param {?proto.iotextypes.StartSubChain|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setStartsubchain = function(value) {
  return jspb.Message.setOneofWrapperField(this, 13, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearStartsubchain = function() {
  return this.setStartsubchain(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasStartsubchain = function() {
  return jspb.Message.getField(this, 13) != null;
};


/**
 * optional StopSubChain stopSubChain = 14;
 * @return {?proto.iotextypes.StopSubChain}
 */
proto.iotextypes.ActionCore.prototype.getStopsubchain = function() {
  return /** @type{?proto.iotextypes.StopSubChain} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.StopSubChain, 14));
};


/**
 * @param {?proto.iotextypes.StopSubChain|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setStopsubchain = function(value) {
  return jspb.Message.setOneofWrapperField(this, 14, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearStopsubchain = function() {
  return this.setStopsubchain(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasStopsubchain = function() {
  return jspb.Message.getField(this, 14) != null;
};


/**
 * optional PutBlock putBlock = 15;
 * @return {?proto.iotextypes.PutBlock}
 */
proto.iotextypes.ActionCore.prototype.getPutblock = function() {
  return /** @type{?proto.iotextypes.PutBlock} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.PutBlock, 15));
};


/**
 * @param {?proto.iotextypes.PutBlock|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setPutblock = function(value) {
  return jspb.Message.setOneofWrapperField(this, 15, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearPutblock = function() {
  return this.setPutblock(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasPutblock = function() {
  return jspb.Message.getField(this, 15) != null;
};


/**
 * optional CreateDeposit createDeposit = 16;
 * @return {?proto.iotextypes.CreateDeposit}
 */
proto.iotextypes.ActionCore.prototype.getCreatedeposit = function() {
  return /** @type{?proto.iotextypes.CreateDeposit} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.CreateDeposit, 16));
};


/**
 * @param {?proto.iotextypes.CreateDeposit|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setCreatedeposit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 16, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearCreatedeposit = function() {
  return this.setCreatedeposit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasCreatedeposit = function() {
  return jspb.Message.getField(this, 16) != null;
};


/**
 * optional SettleDeposit settleDeposit = 17;
 * @return {?proto.iotextypes.SettleDeposit}
 */
proto.iotextypes.ActionCore.prototype.getSettledeposit = function() {
  return /** @type{?proto.iotextypes.SettleDeposit} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.SettleDeposit, 17));
};


/**
 * @param {?proto.iotextypes.SettleDeposit|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setSettledeposit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 17, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearSettledeposit = function() {
  return this.setSettledeposit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasSettledeposit = function() {
  return jspb.Message.getField(this, 17) != null;
};


/**
 * optional CreatePlumChain createPlumChain = 18;
 * @return {?proto.iotextypes.CreatePlumChain}
 */
proto.iotextypes.ActionCore.prototype.getCreateplumchain = function() {
  return /** @type{?proto.iotextypes.CreatePlumChain} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.CreatePlumChain, 18));
};


/**
 * @param {?proto.iotextypes.CreatePlumChain|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setCreateplumchain = function(value) {
  return jspb.Message.setOneofWrapperField(this, 18, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearCreateplumchain = function() {
  return this.setCreateplumchain(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasCreateplumchain = function() {
  return jspb.Message.getField(this, 18) != null;
};


/**
 * optional TerminatePlumChain terminatePlumChain = 19;
 * @return {?proto.iotextypes.TerminatePlumChain}
 */
proto.iotextypes.ActionCore.prototype.getTerminateplumchain = function() {
  return /** @type{?proto.iotextypes.TerminatePlumChain} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.TerminatePlumChain, 19));
};


/**
 * @param {?proto.iotextypes.TerminatePlumChain|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setTerminateplumchain = function(value) {
  return jspb.Message.setOneofWrapperField(this, 19, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearTerminateplumchain = function() {
  return this.setTerminateplumchain(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasTerminateplumchain = function() {
  return jspb.Message.getField(this, 19) != null;
};


/**
 * optional PlumPutBlock plumPutBlock = 20;
 * @return {?proto.iotextypes.PlumPutBlock}
 */
proto.iotextypes.ActionCore.prototype.getPlumputblock = function() {
  return /** @type{?proto.iotextypes.PlumPutBlock} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.PlumPutBlock, 20));
};


/**
 * @param {?proto.iotextypes.PlumPutBlock|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setPlumputblock = function(value) {
  return jspb.Message.setOneofWrapperField(this, 20, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearPlumputblock = function() {
  return this.setPlumputblock(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasPlumputblock = function() {
  return jspb.Message.getField(this, 20) != null;
};


/**
 * optional PlumCreateDeposit plumCreateDeposit = 21;
 * @return {?proto.iotextypes.PlumCreateDeposit}
 */
proto.iotextypes.ActionCore.prototype.getPlumcreatedeposit = function() {
  return /** @type{?proto.iotextypes.PlumCreateDeposit} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.PlumCreateDeposit, 21));
};


/**
 * @param {?proto.iotextypes.PlumCreateDeposit|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setPlumcreatedeposit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 21, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearPlumcreatedeposit = function() {
  return this.setPlumcreatedeposit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasPlumcreatedeposit = function() {
  return jspb.Message.getField(this, 21) != null;
};


/**
 * optional PlumStartExit plumStartExit = 22;
 * @return {?proto.iotextypes.PlumStartExit}
 */
proto.iotextypes.ActionCore.prototype.getPlumstartexit = function() {
  return /** @type{?proto.iotextypes.PlumStartExit} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.PlumStartExit, 22));
};


/**
 * @param {?proto.iotextypes.PlumStartExit|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setPlumstartexit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 22, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearPlumstartexit = function() {
  return this.setPlumstartexit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasPlumstartexit = function() {
  return jspb.Message.getField(this, 22) != null;
};


/**
 * optional PlumChallengeExit plumChallengeExit = 23;
 * @return {?proto.iotextypes.PlumChallengeExit}
 */
proto.iotextypes.ActionCore.prototype.getPlumchallengeexit = function() {
  return /** @type{?proto.iotextypes.PlumChallengeExit} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.PlumChallengeExit, 23));
};


/**
 * @param {?proto.iotextypes.PlumChallengeExit|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setPlumchallengeexit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 23, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearPlumchallengeexit = function() {
  return this.setPlumchallengeexit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasPlumchallengeexit = function() {
  return jspb.Message.getField(this, 23) != null;
};


/**
 * optional PlumResponseChallengeExit plumResponseChallengeExit = 24;
 * @return {?proto.iotextypes.PlumResponseChallengeExit}
 */
proto.iotextypes.ActionCore.prototype.getPlumresponsechallengeexit = function() {
  return /** @type{?proto.iotextypes.PlumResponseChallengeExit} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.PlumResponseChallengeExit, 24));
};


/**
 * @param {?proto.iotextypes.PlumResponseChallengeExit|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setPlumresponsechallengeexit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 24, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearPlumresponsechallengeexit = function() {
  return this.setPlumresponsechallengeexit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasPlumresponsechallengeexit = function() {
  return jspb.Message.getField(this, 24) != null;
};


/**
 * optional PlumFinalizeExit plumFinalizeExit = 25;
 * @return {?proto.iotextypes.PlumFinalizeExit}
 */
proto.iotextypes.ActionCore.prototype.getPlumfinalizeexit = function() {
  return /** @type{?proto.iotextypes.PlumFinalizeExit} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.PlumFinalizeExit, 25));
};


/**
 * @param {?proto.iotextypes.PlumFinalizeExit|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setPlumfinalizeexit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 25, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearPlumfinalizeexit = function() {
  return this.setPlumfinalizeexit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasPlumfinalizeexit = function() {
  return jspb.Message.getField(this, 25) != null;
};


/**
 * optional PlumSettleDeposit plumSettleDeposit = 26;
 * @return {?proto.iotextypes.PlumSettleDeposit}
 */
proto.iotextypes.ActionCore.prototype.getPlumsettledeposit = function() {
  return /** @type{?proto.iotextypes.PlumSettleDeposit} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.PlumSettleDeposit, 26));
};


/**
 * @param {?proto.iotextypes.PlumSettleDeposit|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setPlumsettledeposit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 26, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearPlumsettledeposit = function() {
  return this.setPlumsettledeposit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasPlumsettledeposit = function() {
  return jspb.Message.getField(this, 26) != null;
};


/**
 * optional PlumTransfer plumTransfer = 27;
 * @return {?proto.iotextypes.PlumTransfer}
 */
proto.iotextypes.ActionCore.prototype.getPlumtransfer = function() {
  return /** @type{?proto.iotextypes.PlumTransfer} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.PlumTransfer, 27));
};


/**
 * @param {?proto.iotextypes.PlumTransfer|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setPlumtransfer = function(value) {
  return jspb.Message.setOneofWrapperField(this, 27, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearPlumtransfer = function() {
  return this.setPlumtransfer(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasPlumtransfer = function() {
  return jspb.Message.getField(this, 27) != null;
};


/**
 * optional DepositToRewardingFund depositToRewardingFund = 30;
 * @return {?proto.iotextypes.DepositToRewardingFund}
 */
proto.iotextypes.ActionCore.prototype.getDeposittorewardingfund = function() {
  return /** @type{?proto.iotextypes.DepositToRewardingFund} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.DepositToRewardingFund, 30));
};


/**
 * @param {?proto.iotextypes.DepositToRewardingFund|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setDeposittorewardingfund = function(value) {
  return jspb.Message.setOneofWrapperField(this, 30, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearDeposittorewardingfund = function() {
  return this.setDeposittorewardingfund(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasDeposittorewardingfund = function() {
  return jspb.Message.getField(this, 30) != null;
};


/**
 * optional ClaimFromRewardingFund claimFromRewardingFund = 31;
 * @return {?proto.iotextypes.ClaimFromRewardingFund}
 */
proto.iotextypes.ActionCore.prototype.getClaimfromrewardingfund = function() {
  return /** @type{?proto.iotextypes.ClaimFromRewardingFund} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.ClaimFromRewardingFund, 31));
};


/**
 * @param {?proto.iotextypes.ClaimFromRewardingFund|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setClaimfromrewardingfund = function(value) {
  return jspb.Message.setOneofWrapperField(this, 31, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearClaimfromrewardingfund = function() {
  return this.setClaimfromrewardingfund(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasClaimfromrewardingfund = function() {
  return jspb.Message.getField(this, 31) != null;
};


/**
 * optional GrantReward grantReward = 32;
 * @return {?proto.iotextypes.GrantReward}
 */
proto.iotextypes.ActionCore.prototype.getGrantreward = function() {
  return /** @type{?proto.iotextypes.GrantReward} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.GrantReward, 32));
};


/**
 * @param {?proto.iotextypes.GrantReward|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setGrantreward = function(value) {
  return jspb.Message.setOneofWrapperField(this, 32, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearGrantreward = function() {
  return this.setGrantreward(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasGrantreward = function() {
  return jspb.Message.getField(this, 32) != null;
};


/**
 * optional StakeCreate stakeCreate = 40;
 * @return {?proto.iotextypes.StakeCreate}
 */
proto.iotextypes.ActionCore.prototype.getStakecreate = function() {
  return /** @type{?proto.iotextypes.StakeCreate} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.StakeCreate, 40));
};


/**
 * @param {?proto.iotextypes.StakeCreate|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setStakecreate = function(value) {
  return jspb.Message.setOneofWrapperField(this, 40, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearStakecreate = function() {
  return this.setStakecreate(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasStakecreate = function() {
  return jspb.Message.getField(this, 40) != null;
};


/**
 * optional StakeReclaim stakeUnstake = 41;
 * @return {?proto.iotextypes.StakeReclaim}
 */
proto.iotextypes.ActionCore.prototype.getStakeunstake = function() {
  return /** @type{?proto.iotextypes.StakeReclaim} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.StakeReclaim, 41));
};


/**
 * @param {?proto.iotextypes.StakeReclaim|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setStakeunstake = function(value) {
  return jspb.Message.setOneofWrapperField(this, 41, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearStakeunstake = function() {
  return this.setStakeunstake(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasStakeunstake = function() {
  return jspb.Message.getField(this, 41) != null;
};


/**
 * optional StakeReclaim stakeWithdraw = 42;
 * @return {?proto.iotextypes.StakeReclaim}
 */
proto.iotextypes.ActionCore.prototype.getStakewithdraw = function() {
  return /** @type{?proto.iotextypes.StakeReclaim} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.StakeReclaim, 42));
};


/**
 * @param {?proto.iotextypes.StakeReclaim|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setStakewithdraw = function(value) {
  return jspb.Message.setOneofWrapperField(this, 42, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearStakewithdraw = function() {
  return this.setStakewithdraw(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasStakewithdraw = function() {
  return jspb.Message.getField(this, 42) != null;
};


/**
 * optional StakeAddDeposit stakeAddDeposit = 43;
 * @return {?proto.iotextypes.StakeAddDeposit}
 */
proto.iotextypes.ActionCore.prototype.getStakeadddeposit = function() {
  return /** @type{?proto.iotextypes.StakeAddDeposit} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.StakeAddDeposit, 43));
};


/**
 * @param {?proto.iotextypes.StakeAddDeposit|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setStakeadddeposit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 43, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearStakeadddeposit = function() {
  return this.setStakeadddeposit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasStakeadddeposit = function() {
  return jspb.Message.getField(this, 43) != null;
};


/**
 * optional StakeRestake stakeRestake = 44;
 * @return {?proto.iotextypes.StakeRestake}
 */
proto.iotextypes.ActionCore.prototype.getStakerestake = function() {
  return /** @type{?proto.iotextypes.StakeRestake} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.StakeRestake, 44));
};


/**
 * @param {?proto.iotextypes.StakeRestake|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setStakerestake = function(value) {
  return jspb.Message.setOneofWrapperField(this, 44, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearStakerestake = function() {
  return this.setStakerestake(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasStakerestake = function() {
  return jspb.Message.getField(this, 44) != null;
};


/**
 * optional StakeChangeCandidate stakeChangeCandidate = 45;
 * @return {?proto.iotextypes.StakeChangeCandidate}
 */
proto.iotextypes.ActionCore.prototype.getStakechangecandidate = function() {
  return /** @type{?proto.iotextypes.StakeChangeCandidate} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.StakeChangeCandidate, 45));
};


/**
 * @param {?proto.iotextypes.StakeChangeCandidate|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setStakechangecandidate = function(value) {
  return jspb.Message.setOneofWrapperField(this, 45, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearStakechangecandidate = function() {
  return this.setStakechangecandidate(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasStakechangecandidate = function() {
  return jspb.Message.getField(this, 45) != null;
};


/**
 * optional StakeTransferOwnership stakeTransferOwnership = 46;
 * @return {?proto.iotextypes.StakeTransferOwnership}
 */
proto.iotextypes.ActionCore.prototype.getStaketransferownership = function() {
  return /** @type{?proto.iotextypes.StakeTransferOwnership} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.StakeTransferOwnership, 46));
};


/**
 * @param {?proto.iotextypes.StakeTransferOwnership|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setStaketransferownership = function(value) {
  return jspb.Message.setOneofWrapperField(this, 46, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearStaketransferownership = function() {
  return this.setStaketransferownership(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasStaketransferownership = function() {
  return jspb.Message.getField(this, 46) != null;
};


/**
 * optional CandidateRegister candidateRegister = 47;
 * @return {?proto.iotextypes.CandidateRegister}
 */
proto.iotextypes.ActionCore.prototype.getCandidateregister = function() {
  return /** @type{?proto.iotextypes.CandidateRegister} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.CandidateRegister, 47));
};


/**
 * @param {?proto.iotextypes.CandidateRegister|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setCandidateregister = function(value) {
  return jspb.Message.setOneofWrapperField(this, 47, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearCandidateregister = function() {
  return this.setCandidateregister(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasCandidateregister = function() {
  return jspb.Message.getField(this, 47) != null;
};


/**
 * optional CandidateBasicInfo candidateUpdate = 48;
 * @return {?proto.iotextypes.CandidateBasicInfo}
 */
proto.iotextypes.ActionCore.prototype.getCandidateupdate = function() {
  return /** @type{?proto.iotextypes.CandidateBasicInfo} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.CandidateBasicInfo, 48));
};


/**
 * @param {?proto.iotextypes.CandidateBasicInfo|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setCandidateupdate = function(value) {
  return jspb.Message.setOneofWrapperField(this, 48, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearCandidateupdate = function() {
  return this.setCandidateupdate(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasCandidateupdate = function() {
  return jspb.Message.getField(this, 48) != null;
};


/**
 * optional PutPollResult putPollResult = 50;
 * @return {?proto.iotextypes.PutPollResult}
 */
proto.iotextypes.ActionCore.prototype.getPutpollresult = function() {
  return /** @type{?proto.iotextypes.PutPollResult} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.PutPollResult, 50));
};


/**
 * @param {?proto.iotextypes.PutPollResult|undefined} value
 * @return {!proto.iotextypes.ActionCore} returns this
*/
proto.iotextypes.ActionCore.prototype.setPutpollresult = function(value) {
  return jspb.Message.setOneofWrapperField(this, 50, proto.iotextypes.ActionCore.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.ActionCore} returns this
 */
proto.iotextypes.ActionCore.prototype.clearPutpollresult = function() {
  return this.setPutpollresult(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.ActionCore.prototype.hasPutpollresult = function() {
  return jspb.Message.getField(this, 50) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.Action.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.Action.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.Action} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.Action.toObject = function(includeInstance, msg) {
  var f, obj = {
    core: (f = msg.getCore()) && proto.iotextypes.ActionCore.toObject(includeInstance, f),
    senderpubkey: msg.getSenderpubkey_asB64(),
    signature: msg.getSignature_asB64(),
    encoding: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.Action}
 */
proto.iotextypes.Action.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.Action;
  return proto.iotextypes.Action.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.Action} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.Action}
 */
proto.iotextypes.Action.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.iotextypes.ActionCore;
      reader.readMessage(value,proto.iotextypes.ActionCore.deserializeBinaryFromReader);
      msg.setCore(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSenderpubkey(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    case 4:
      var value = /** @type {!proto.iotextypes.Encoding} */ (reader.readEnum());
      msg.setEncoding(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.Action.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.Action.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.Action} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.Action.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCore();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.iotextypes.ActionCore.serializeBinaryToWriter
    );
  }
  f = message.getSenderpubkey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getEncoding();
  if (f !== 0.0) {
    writer.writeEnum(
      4,
      f
    );
  }
};


/**
 * optional ActionCore core = 1;
 * @return {?proto.iotextypes.ActionCore}
 */
proto.iotextypes.Action.prototype.getCore = function() {
  return /** @type{?proto.iotextypes.ActionCore} */ (
    jspb.Message.getWrapperField(this, proto.iotextypes.ActionCore, 1));
};


/**
 * @param {?proto.iotextypes.ActionCore|undefined} value
 * @return {!proto.iotextypes.Action} returns this
*/
proto.iotextypes.Action.prototype.setCore = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.iotextypes.Action} returns this
 */
proto.iotextypes.Action.prototype.clearCore = function() {
  return this.setCore(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.iotextypes.Action.prototype.hasCore = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes senderPubKey = 2;
 * @return {string}
 */
proto.iotextypes.Action.prototype.getSenderpubkey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes senderPubKey = 2;
 * This is a type-conversion wrapper around `getSenderpubkey()`
 * @return {string}
 */
proto.iotextypes.Action.prototype.getSenderpubkey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSenderpubkey()));
};


/**
 * optional bytes senderPubKey = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSenderpubkey()`
 * @return {!Uint8Array}
 */
proto.iotextypes.Action.prototype.getSenderpubkey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSenderpubkey()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.Action} returns this
 */
proto.iotextypes.Action.prototype.setSenderpubkey = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional bytes signature = 3;
 * @return {string}
 */
proto.iotextypes.Action.prototype.getSignature = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes signature = 3;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.iotextypes.Action.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.iotextypes.Action.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.Action} returns this
 */
proto.iotextypes.Action.prototype.setSignature = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional Encoding encoding = 4;
 * @return {!proto.iotextypes.Encoding}
 */
proto.iotextypes.Action.prototype.getEncoding = function() {
  return /** @type {!proto.iotextypes.Encoding} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {!proto.iotextypes.Encoding} value
 * @return {!proto.iotextypes.Action} returns this
 */
proto.iotextypes.Action.prototype.setEncoding = function(value) {
  return jspb.Message.setProto3EnumField(this, 4, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.iotextypes.Receipt.repeatedFields_ = [6];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.Receipt.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.Receipt.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.Receipt} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.Receipt.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: jspb.Message.getFieldWithDefault(msg, 1, 0),
    blkheight: jspb.Message.getFieldWithDefault(msg, 2, 0),
    acthash: msg.getActhash_asB64(),
    gasconsumed: jspb.Message.getFieldWithDefault(msg, 4, 0),
    contractaddress: jspb.Message.getFieldWithDefault(msg, 5, ""),
    logsList: jspb.Message.toObjectList(msg.getLogsList(),
    proto.iotextypes.Log.toObject, includeInstance),
    executionrevertmsg: jspb.Message.getFieldWithDefault(msg, 7, ""),
    txindex: jspb.Message.getFieldWithDefault(msg, 8, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.Receipt}
 */
proto.iotextypes.Receipt.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.Receipt;
  return proto.iotextypes.Receipt.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.Receipt} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.Receipt}
 */
proto.iotextypes.Receipt.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setStatus(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setBlkheight(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setActhash(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setGasconsumed(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractaddress(value);
      break;
    case 6:
      var value = new proto.iotextypes.Log;
      reader.readMessage(value,proto.iotextypes.Log.deserializeBinaryFromReader);
      msg.addLogs(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setExecutionrevertmsg(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setTxindex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.Receipt.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.Receipt.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.Receipt} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.Receipt.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStatus();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getBlkheight();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getActhash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getGasconsumed();
  if (f !== 0) {
    writer.writeUint64(
      4,
      f
    );
  }
  f = message.getContractaddress();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getLogsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      6,
      f,
      proto.iotextypes.Log.serializeBinaryToWriter
    );
  }
  f = message.getExecutionrevertmsg();
  if (f.length > 0) {
    writer.writeString(
      7,
      f
    );
  }
  f = message.getTxindex();
  if (f !== 0) {
    writer.writeUint32(
      8,
      f
    );
  }
};


/**
 * optional uint64 status = 1;
 * @return {number}
 */
proto.iotextypes.Receipt.prototype.getStatus = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.Receipt} returns this
 */
proto.iotextypes.Receipt.prototype.setStatus = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 blkHeight = 2;
 * @return {number}
 */
proto.iotextypes.Receipt.prototype.getBlkheight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.Receipt} returns this
 */
proto.iotextypes.Receipt.prototype.setBlkheight = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bytes actHash = 3;
 * @return {string}
 */
proto.iotextypes.Receipt.prototype.getActhash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes actHash = 3;
 * This is a type-conversion wrapper around `getActhash()`
 * @return {string}
 */
proto.iotextypes.Receipt.prototype.getActhash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getActhash()));
};


/**
 * optional bytes actHash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getActhash()`
 * @return {!Uint8Array}
 */
proto.iotextypes.Receipt.prototype.getActhash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getActhash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.Receipt} returns this
 */
proto.iotextypes.Receipt.prototype.setActhash = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional uint64 gasConsumed = 4;
 * @return {number}
 */
proto.iotextypes.Receipt.prototype.getGasconsumed = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.Receipt} returns this
 */
proto.iotextypes.Receipt.prototype.setGasconsumed = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional string contractAddress = 5;
 * @return {string}
 */
proto.iotextypes.Receipt.prototype.getContractaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.Receipt} returns this
 */
proto.iotextypes.Receipt.prototype.setContractaddress = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};


/**
 * repeated Log logs = 6;
 * @return {!Array<!proto.iotextypes.Log>}
 */
proto.iotextypes.Receipt.prototype.getLogsList = function() {
  return /** @type{!Array<!proto.iotextypes.Log>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.iotextypes.Log, 6));
};


/**
 * @param {!Array<!proto.iotextypes.Log>} value
 * @return {!proto.iotextypes.Receipt} returns this
*/
proto.iotextypes.Receipt.prototype.setLogsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 6, value);
};


/**
 * @param {!proto.iotextypes.Log=} opt_value
 * @param {number=} opt_index
 * @return {!proto.iotextypes.Log}
 */
proto.iotextypes.Receipt.prototype.addLogs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 6, opt_value, proto.iotextypes.Log, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.iotextypes.Receipt} returns this
 */
proto.iotextypes.Receipt.prototype.clearLogsList = function() {
  return this.setLogsList([]);
};


/**
 * optional string executionRevertMsg = 7;
 * @return {string}
 */
proto.iotextypes.Receipt.prototype.getExecutionrevertmsg = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.Receipt} returns this
 */
proto.iotextypes.Receipt.prototype.setExecutionrevertmsg = function(value) {
  return jspb.Message.setProto3StringField(this, 7, value);
};


/**
 * optional uint32 txIndex = 8;
 * @return {number}
 */
proto.iotextypes.Receipt.prototype.getTxindex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.Receipt} returns this
 */
proto.iotextypes.Receipt.prototype.setTxindex = function(value) {
  return jspb.Message.setProto3IntField(this, 8, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.iotextypes.Log.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.Log.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.Log.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.Log} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.Log.toObject = function(includeInstance, msg) {
  var f, obj = {
    contractaddress: jspb.Message.getFieldWithDefault(msg, 1, ""),
    topicsList: msg.getTopicsList_asB64(),
    data: msg.getData_asB64(),
    blkheight: jspb.Message.getFieldWithDefault(msg, 4, 0),
    acthash: msg.getActhash_asB64(),
    index: jspb.Message.getFieldWithDefault(msg, 6, 0),
    blkhash: msg.getBlkhash_asB64(),
    txindex: jspb.Message.getFieldWithDefault(msg, 8, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.Log}
 */
proto.iotextypes.Log.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.Log;
  return proto.iotextypes.Log.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.Log} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.Log}
 */
proto.iotextypes.Log.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setContractaddress(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addTopics(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setData(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setBlkheight(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setActhash(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setIndex(value);
      break;
    case 7:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBlkhash(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setTxindex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.Log.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.Log.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.Log} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.Log.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getContractaddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getTopicsList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      2,
      f
    );
  }
  f = message.getData_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getBlkheight();
  if (f !== 0) {
    writer.writeUint64(
      4,
      f
    );
  }
  f = message.getActhash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = message.getIndex();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = message.getBlkhash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      7,
      f
    );
  }
  f = message.getTxindex();
  if (f !== 0) {
    writer.writeUint32(
      8,
      f
    );
  }
};


/**
 * optional string contractAddress = 1;
 * @return {string}
 */
proto.iotextypes.Log.prototype.getContractaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.Log} returns this
 */
proto.iotextypes.Log.prototype.setContractaddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * repeated bytes topics = 2;
 * @return {!Array<string>}
 */
proto.iotextypes.Log.prototype.getTopicsList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 2));
};


/**
 * repeated bytes topics = 2;
 * This is a type-conversion wrapper around `getTopicsList()`
 * @return {!Array<string>}
 */
proto.iotextypes.Log.prototype.getTopicsList_asB64 = function() {
  return /** @type {!Array<string>} */ (jspb.Message.bytesListAsB64(
      this.getTopicsList()));
};


/**
 * repeated bytes topics = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTopicsList()`
 * @return {!Array<!Uint8Array>}
 */
proto.iotextypes.Log.prototype.getTopicsList_asU8 = function() {
  return /** @type {!Array<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getTopicsList()));
};


/**
 * @param {!(Array<!Uint8Array>|Array<string>)} value
 * @return {!proto.iotextypes.Log} returns this
 */
proto.iotextypes.Log.prototype.setTopicsList = function(value) {
  return jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 * @return {!proto.iotextypes.Log} returns this
 */
proto.iotextypes.Log.prototype.addTopics = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.iotextypes.Log} returns this
 */
proto.iotextypes.Log.prototype.clearTopicsList = function() {
  return this.setTopicsList([]);
};


/**
 * optional bytes data = 3;
 * @return {string}
 */
proto.iotextypes.Log.prototype.getData = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes data = 3;
 * This is a type-conversion wrapper around `getData()`
 * @return {string}
 */
proto.iotextypes.Log.prototype.getData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getData()));
};


/**
 * optional bytes data = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getData()`
 * @return {!Uint8Array}
 */
proto.iotextypes.Log.prototype.getData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getData()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.Log} returns this
 */
proto.iotextypes.Log.prototype.setData = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional uint64 blkHeight = 4;
 * @return {number}
 */
proto.iotextypes.Log.prototype.getBlkheight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.Log} returns this
 */
proto.iotextypes.Log.prototype.setBlkheight = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional bytes actHash = 5;
 * @return {string}
 */
proto.iotextypes.Log.prototype.getActhash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes actHash = 5;
 * This is a type-conversion wrapper around `getActhash()`
 * @return {string}
 */
proto.iotextypes.Log.prototype.getActhash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getActhash()));
};


/**
 * optional bytes actHash = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getActhash()`
 * @return {!Uint8Array}
 */
proto.iotextypes.Log.prototype.getActhash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getActhash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.Log} returns this
 */
proto.iotextypes.Log.prototype.setActhash = function(value) {
  return jspb.Message.setProto3BytesField(this, 5, value);
};


/**
 * optional uint32 index = 6;
 * @return {number}
 */
proto.iotextypes.Log.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.Log} returns this
 */
proto.iotextypes.Log.prototype.setIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 6, value);
};


/**
 * optional bytes blkHash = 7;
 * @return {string}
 */
proto.iotextypes.Log.prototype.getBlkhash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * optional bytes blkHash = 7;
 * This is a type-conversion wrapper around `getBlkhash()`
 * @return {string}
 */
proto.iotextypes.Log.prototype.getBlkhash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBlkhash()));
};


/**
 * optional bytes blkHash = 7;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlkhash()`
 * @return {!Uint8Array}
 */
proto.iotextypes.Log.prototype.getBlkhash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBlkhash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.Log} returns this
 */
proto.iotextypes.Log.prototype.setBlkhash = function(value) {
  return jspb.Message.setProto3BytesField(this, 7, value);
};


/**
 * optional uint32 txIndex = 8;
 * @return {number}
 */
proto.iotextypes.Log.prototype.getTxindex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.Log} returns this
 */
proto.iotextypes.Log.prototype.setTxindex = function(value) {
  return jspb.Message.setProto3IntField(this, 8, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.iotextypes.Logs.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.Logs.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.Logs.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.Logs} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.Logs.toObject = function(includeInstance, msg) {
  var f, obj = {
    logsList: jspb.Message.toObjectList(msg.getLogsList(),
    proto.iotextypes.Log.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.Logs}
 */
proto.iotextypes.Logs.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.Logs;
  return proto.iotextypes.Logs.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.Logs} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.Logs}
 */
proto.iotextypes.Logs.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.iotextypes.Log;
      reader.readMessage(value,proto.iotextypes.Log.deserializeBinaryFromReader);
      msg.addLogs(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.Logs.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.Logs.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.Logs} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.Logs.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLogsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.iotextypes.Log.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Log logs = 1;
 * @return {!Array<!proto.iotextypes.Log>}
 */
proto.iotextypes.Logs.prototype.getLogsList = function() {
  return /** @type{!Array<!proto.iotextypes.Log>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.iotextypes.Log, 1));
};


/**
 * @param {!Array<!proto.iotextypes.Log>} value
 * @return {!proto.iotextypes.Logs} returns this
*/
proto.iotextypes.Logs.prototype.setLogsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.iotextypes.Log=} opt_value
 * @param {number=} opt_index
 * @return {!proto.iotextypes.Log}
 */
proto.iotextypes.Logs.prototype.addLogs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.iotextypes.Log, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.iotextypes.Logs} returns this
 */
proto.iotextypes.Logs.prototype.clearLogsList = function() {
  return this.setLogsList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.EvmTransfer.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.EvmTransfer.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.EvmTransfer} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.EvmTransfer.toObject = function(includeInstance, msg) {
  var f, obj = {
    amount: msg.getAmount_asB64(),
    from: jspb.Message.getFieldWithDefault(msg, 2, ""),
    to: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.EvmTransfer}
 */
proto.iotextypes.EvmTransfer.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.EvmTransfer;
  return proto.iotextypes.EvmTransfer.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.EvmTransfer} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.EvmTransfer}
 */
proto.iotextypes.EvmTransfer.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAmount(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setFrom(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setTo(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.EvmTransfer.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.EvmTransfer.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.EvmTransfer} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.EvmTransfer.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAmount_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getFrom();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getTo();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional bytes amount = 1;
 * @return {string}
 */
proto.iotextypes.EvmTransfer.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes amount = 1;
 * This is a type-conversion wrapper around `getAmount()`
 * @return {string}
 */
proto.iotextypes.EvmTransfer.prototype.getAmount_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAmount()));
};


/**
 * optional bytes amount = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAmount()`
 * @return {!Uint8Array}
 */
proto.iotextypes.EvmTransfer.prototype.getAmount_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAmount()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.EvmTransfer} returns this
 */
proto.iotextypes.EvmTransfer.prototype.setAmount = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional string from = 2;
 * @return {string}
 */
proto.iotextypes.EvmTransfer.prototype.getFrom = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.EvmTransfer} returns this
 */
proto.iotextypes.EvmTransfer.prototype.setFrom = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string to = 3;
 * @return {string}
 */
proto.iotextypes.EvmTransfer.prototype.getTo = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.EvmTransfer} returns this
 */
proto.iotextypes.EvmTransfer.prototype.setTo = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.iotextypes.EvmTransferList.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.EvmTransferList.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.EvmTransferList.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.EvmTransferList} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.EvmTransferList.toObject = function(includeInstance, msg) {
  var f, obj = {
    evmtransfersList: jspb.Message.toObjectList(msg.getEvmtransfersList(),
    proto.iotextypes.EvmTransfer.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.EvmTransferList}
 */
proto.iotextypes.EvmTransferList.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.EvmTransferList;
  return proto.iotextypes.EvmTransferList.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.EvmTransferList} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.EvmTransferList}
 */
proto.iotextypes.EvmTransferList.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.iotextypes.EvmTransfer;
      reader.readMessage(value,proto.iotextypes.EvmTransfer.deserializeBinaryFromReader);
      msg.addEvmtransfers(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.EvmTransferList.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.EvmTransferList.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.EvmTransferList} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.EvmTransferList.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEvmtransfersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.iotextypes.EvmTransfer.serializeBinaryToWriter
    );
  }
};


/**
 * repeated EvmTransfer evmTransfers = 1;
 * @return {!Array<!proto.iotextypes.EvmTransfer>}
 */
proto.iotextypes.EvmTransferList.prototype.getEvmtransfersList = function() {
  return /** @type{!Array<!proto.iotextypes.EvmTransfer>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.iotextypes.EvmTransfer, 1));
};


/**
 * @param {!Array<!proto.iotextypes.EvmTransfer>} value
 * @return {!proto.iotextypes.EvmTransferList} returns this
*/
proto.iotextypes.EvmTransferList.prototype.setEvmtransfersList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.iotextypes.EvmTransfer=} opt_value
 * @param {number=} opt_index
 * @return {!proto.iotextypes.EvmTransfer}
 */
proto.iotextypes.EvmTransferList.prototype.addEvmtransfers = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.iotextypes.EvmTransfer, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.iotextypes.EvmTransferList} returns this
 */
proto.iotextypes.EvmTransferList.prototype.clearEvmtransfersList = function() {
  return this.setEvmtransfersList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.iotextypes.ActionEvmTransfer.repeatedFields_ = [3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.ActionEvmTransfer.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.ActionEvmTransfer.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.ActionEvmTransfer} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.ActionEvmTransfer.toObject = function(includeInstance, msg) {
  var f, obj = {
    actionhash: msg.getActionhash_asB64(),
    numevmtransfers: jspb.Message.getFieldWithDefault(msg, 2, 0),
    evmtransfersList: jspb.Message.toObjectList(msg.getEvmtransfersList(),
    proto.iotextypes.EvmTransfer.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.ActionEvmTransfer}
 */
proto.iotextypes.ActionEvmTransfer.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.ActionEvmTransfer;
  return proto.iotextypes.ActionEvmTransfer.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.ActionEvmTransfer} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.ActionEvmTransfer}
 */
proto.iotextypes.ActionEvmTransfer.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setActionhash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNumevmtransfers(value);
      break;
    case 3:
      var value = new proto.iotextypes.EvmTransfer;
      reader.readMessage(value,proto.iotextypes.EvmTransfer.deserializeBinaryFromReader);
      msg.addEvmtransfers(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.ActionEvmTransfer.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.ActionEvmTransfer.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.ActionEvmTransfer} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.ActionEvmTransfer.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getActionhash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getNumevmtransfers();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getEvmtransfersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.iotextypes.EvmTransfer.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes actionHash = 1;
 * @return {string}
 */
proto.iotextypes.ActionEvmTransfer.prototype.getActionhash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes actionHash = 1;
 * This is a type-conversion wrapper around `getActionhash()`
 * @return {string}
 */
proto.iotextypes.ActionEvmTransfer.prototype.getActionhash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getActionhash()));
};


/**
 * optional bytes actionHash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getActionhash()`
 * @return {!Uint8Array}
 */
proto.iotextypes.ActionEvmTransfer.prototype.getActionhash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getActionhash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.ActionEvmTransfer} returns this
 */
proto.iotextypes.ActionEvmTransfer.prototype.setActionhash = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional uint64 numEvmTransfers = 2;
 * @return {number}
 */
proto.iotextypes.ActionEvmTransfer.prototype.getNumevmtransfers = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.ActionEvmTransfer} returns this
 */
proto.iotextypes.ActionEvmTransfer.prototype.setNumevmtransfers = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * repeated EvmTransfer evmTransfers = 3;
 * @return {!Array<!proto.iotextypes.EvmTransfer>}
 */
proto.iotextypes.ActionEvmTransfer.prototype.getEvmtransfersList = function() {
  return /** @type{!Array<!proto.iotextypes.EvmTransfer>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.iotextypes.EvmTransfer, 3));
};


/**
 * @param {!Array<!proto.iotextypes.EvmTransfer>} value
 * @return {!proto.iotextypes.ActionEvmTransfer} returns this
*/
proto.iotextypes.ActionEvmTransfer.prototype.setEvmtransfersList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.iotextypes.EvmTransfer=} opt_value
 * @param {number=} opt_index
 * @return {!proto.iotextypes.EvmTransfer}
 */
proto.iotextypes.ActionEvmTransfer.prototype.addEvmtransfers = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.iotextypes.EvmTransfer, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.iotextypes.ActionEvmTransfer} returns this
 */
proto.iotextypes.ActionEvmTransfer.prototype.clearEvmtransfersList = function() {
  return this.setEvmtransfersList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.iotextypes.BlockEvmTransfer.repeatedFields_ = [3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.BlockEvmTransfer.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.BlockEvmTransfer.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.BlockEvmTransfer} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.BlockEvmTransfer.toObject = function(includeInstance, msg) {
  var f, obj = {
    blockheight: jspb.Message.getFieldWithDefault(msg, 1, 0),
    numevmtransfers: jspb.Message.getFieldWithDefault(msg, 2, 0),
    actionevmtransfersList: jspb.Message.toObjectList(msg.getActionevmtransfersList(),
    proto.iotextypes.ActionEvmTransfer.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.BlockEvmTransfer}
 */
proto.iotextypes.BlockEvmTransfer.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.BlockEvmTransfer;
  return proto.iotextypes.BlockEvmTransfer.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.BlockEvmTransfer} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.BlockEvmTransfer}
 */
proto.iotextypes.BlockEvmTransfer.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setBlockheight(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNumevmtransfers(value);
      break;
    case 3:
      var value = new proto.iotextypes.ActionEvmTransfer;
      reader.readMessage(value,proto.iotextypes.ActionEvmTransfer.deserializeBinaryFromReader);
      msg.addActionevmtransfers(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.BlockEvmTransfer.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.BlockEvmTransfer.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.BlockEvmTransfer} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.BlockEvmTransfer.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBlockheight();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getNumevmtransfers();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getActionevmtransfersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.iotextypes.ActionEvmTransfer.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 blockHeight = 1;
 * @return {number}
 */
proto.iotextypes.BlockEvmTransfer.prototype.getBlockheight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.BlockEvmTransfer} returns this
 */
proto.iotextypes.BlockEvmTransfer.prototype.setBlockheight = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 numEvmTransfers = 2;
 * @return {number}
 */
proto.iotextypes.BlockEvmTransfer.prototype.getNumevmtransfers = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.BlockEvmTransfer} returns this
 */
proto.iotextypes.BlockEvmTransfer.prototype.setNumevmtransfers = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * repeated ActionEvmTransfer actionEvmTransfers = 3;
 * @return {!Array<!proto.iotextypes.ActionEvmTransfer>}
 */
proto.iotextypes.BlockEvmTransfer.prototype.getActionevmtransfersList = function() {
  return /** @type{!Array<!proto.iotextypes.ActionEvmTransfer>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.iotextypes.ActionEvmTransfer, 3));
};


/**
 * @param {!Array<!proto.iotextypes.ActionEvmTransfer>} value
 * @return {!proto.iotextypes.BlockEvmTransfer} returns this
*/
proto.iotextypes.BlockEvmTransfer.prototype.setActionevmtransfersList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.iotextypes.ActionEvmTransfer=} opt_value
 * @param {number=} opt_index
 * @return {!proto.iotextypes.ActionEvmTransfer}
 */
proto.iotextypes.BlockEvmTransfer.prototype.addActionevmtransfers = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.iotextypes.ActionEvmTransfer, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.iotextypes.BlockEvmTransfer} returns this
 */
proto.iotextypes.BlockEvmTransfer.prototype.clearActionevmtransfersList = function() {
  return this.setActionevmtransfersList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.DepositToRewardingFund.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.DepositToRewardingFund.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.DepositToRewardingFund} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.DepositToRewardingFund.toObject = function(includeInstance, msg) {
  var f, obj = {
    amount: jspb.Message.getFieldWithDefault(msg, 1, ""),
    data: msg.getData_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.DepositToRewardingFund}
 */
proto.iotextypes.DepositToRewardingFund.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.DepositToRewardingFund;
  return proto.iotextypes.DepositToRewardingFund.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.DepositToRewardingFund} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.DepositToRewardingFund}
 */
proto.iotextypes.DepositToRewardingFund.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.DepositToRewardingFund.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.DepositToRewardingFund.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.DepositToRewardingFund} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.DepositToRewardingFund.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getData_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional string amount = 1;
 * @return {string}
 */
proto.iotextypes.DepositToRewardingFund.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.DepositToRewardingFund} returns this
 */
proto.iotextypes.DepositToRewardingFund.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional bytes data = 2;
 * @return {string}
 */
proto.iotextypes.DepositToRewardingFund.prototype.getData = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes data = 2;
 * This is a type-conversion wrapper around `getData()`
 * @return {string}
 */
proto.iotextypes.DepositToRewardingFund.prototype.getData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getData()));
};


/**
 * optional bytes data = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getData()`
 * @return {!Uint8Array}
 */
proto.iotextypes.DepositToRewardingFund.prototype.getData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getData()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.DepositToRewardingFund} returns this
 */
proto.iotextypes.DepositToRewardingFund.prototype.setData = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.ClaimFromRewardingFund.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.ClaimFromRewardingFund.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.ClaimFromRewardingFund} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.ClaimFromRewardingFund.toObject = function(includeInstance, msg) {
  var f, obj = {
    amount: jspb.Message.getFieldWithDefault(msg, 1, ""),
    data: msg.getData_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.ClaimFromRewardingFund}
 */
proto.iotextypes.ClaimFromRewardingFund.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.ClaimFromRewardingFund;
  return proto.iotextypes.ClaimFromRewardingFund.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.ClaimFromRewardingFund} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.ClaimFromRewardingFund}
 */
proto.iotextypes.ClaimFromRewardingFund.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.ClaimFromRewardingFund.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.ClaimFromRewardingFund.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.ClaimFromRewardingFund} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.ClaimFromRewardingFund.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getData_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional string amount = 1;
 * @return {string}
 */
proto.iotextypes.ClaimFromRewardingFund.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.iotextypes.ClaimFromRewardingFund} returns this
 */
proto.iotextypes.ClaimFromRewardingFund.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional bytes data = 2;
 * @return {string}
 */
proto.iotextypes.ClaimFromRewardingFund.prototype.getData = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes data = 2;
 * This is a type-conversion wrapper around `getData()`
 * @return {string}
 */
proto.iotextypes.ClaimFromRewardingFund.prototype.getData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getData()));
};


/**
 * optional bytes data = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getData()`
 * @return {!Uint8Array}
 */
proto.iotextypes.ClaimFromRewardingFund.prototype.getData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getData()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.iotextypes.ClaimFromRewardingFund} returns this
 */
proto.iotextypes.ClaimFromRewardingFund.prototype.setData = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.iotextypes.GrantReward.prototype.toObject = function(opt_includeInstance) {
  return proto.iotextypes.GrantReward.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.iotextypes.GrantReward} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.GrantReward.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getFieldWithDefault(msg, 1, 0),
    height: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.iotextypes.GrantReward}
 */
proto.iotextypes.GrantReward.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.iotextypes.GrantReward;
  return proto.iotextypes.GrantReward.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.iotextypes.GrantReward} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.iotextypes.GrantReward}
 */
proto.iotextypes.GrantReward.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.iotextypes.RewardType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.iotextypes.GrantReward.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.iotextypes.GrantReward.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.iotextypes.GrantReward} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.iotextypes.GrantReward.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getHeight();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
};


/**
 * optional RewardType type = 1;
 * @return {!proto.iotextypes.RewardType}
 */
proto.iotextypes.GrantReward.prototype.getType = function() {
  return /** @type {!proto.iotextypes.RewardType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.iotextypes.RewardType} value
 * @return {!proto.iotextypes.GrantReward} returns this
 */
proto.iotextypes.GrantReward.prototype.setType = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional uint64 height = 2;
 * @return {number}
 */
proto.iotextypes.GrantReward.prototype.getHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.iotextypes.GrantReward} returns this
 */
proto.iotextypes.GrantReward.prototype.setHeight = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * @enum {number}
 */
proto.iotextypes.Encoding = {
  IOTEX_PROTOBUF: 0,
  ETHEREUM_RLP: 1
};

/**
 * @enum {number}
 */
proto.iotextypes.RewardType = {
  BLOCKREWARD: 0,
  EPOCHREWARD: 1
};

goog.object.extend(exports, proto.iotextypes);
